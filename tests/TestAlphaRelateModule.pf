
!###############################################################################

module TestAlphaRelateModule
  use ISO_Fortran_env, STDOUT => output_unit
  use pFUnit_mod
  use ConstantModule, only : IDLENGTH
  use AlphaHouseMod, only : Int2Char, Log2Char
  use AlphaRelateModule

  implicit none

  CHARACTER(len=100), PARAMETER :: TESTPEDFILE = "TestPedigree.txt"
  CHARACTER(len=100), PARAMETER :: TESTINBFILE = "TestInb.txt"
  CHARACTER(len=100), PARAMETER :: TESTNRMFILE = "TestNrm.txt"
  CHARACTER(len=100), PARAMETER :: TESTPEDNRMSUBSETFILE = "TestPedNrmSubset.txt"

  contains

    !###########################################################################

    @before
    subroutine Setup
      implicit none
    end subroutine

    !###########################################################################

    @after
    subroutine Finish
      implicit none
    end subroutine

    !###########################################################################

    subroutine CreateTinyPedigreeFile
      implicit none
      integer(int32) :: Unit
      open(newunit=Unit, file=TESTPEDFILE, action="write", status="unknown")
      ! From the Mrode's book (2014)
      write(Unit, "(a)") "A 0 0"
      write(Unit, "(a)") "B 0 0"
      write(Unit, "(a)") "C A B"
      write(Unit, "(a)") "D A 0"
      write(Unit, "(a)") "E D C"
      write(Unit, "(a)") "F E B"
      close(Unit)
    end subroutine

    !###########################################################################

    subroutine CreatePedigreeFile
      implicit none
      integer(int32) :: Unit
      open(newunit=Unit, file=TESTPEDFILE, action="write", status="unknown")
      ! From Garcia-Cortes et al. (2013) http://dx.doi.org/10.1371/journal.pone.0057003
      write(Unit, "(a)") "Porto 0 0"
      write(Unit, "(a)") "OldMoll 0 0"
      write(Unit, "(a)") "Dash1 Porto OldMoll"
      write(Unit, "(a)") "Belle1 Porto OldMoll"
      write(Unit, "(a)") "Cora1 Dash1 Belle1"
      write(Unit, "(a)") "Moll2 Dash1 Belle1"
      write(Unit, "(a)") "Pilot Dash1 Belle1"
      write(Unit, "(a)") "Peg Dash1 Moll2"
      write(Unit, "(a)") "Rock Pilot Moll2"
      write(Unit, "(a)") "Regent Pilot Moll2"
      write(Unit, "(a)") "Jet1 Pilot Moll2"
      write(Unit, "(a)") "RockA Peg Rock"
      write(Unit, "(a)") "CoraBlairs Regent Jet1"
      write(Unit, "(a)") "Rock2 Regent Jet1"
      write(Unit, "(a)") "Fred1 RockA Moll2"
      write(Unit, "(a)") "Sting CoraBlairs Rock2"
      write(Unit, "(a)") "Belle2 CoraBlairs Rock2"
      write(Unit, "(a)") "Cora2 Cora1 Fred1"
      write(Unit, "(a)") "Moll3 Fred1 Belle2"
      write(Unit, "(a)") "Dash2 Cora2 Sting"
      close(Unit)
    end subroutine

    !###########################################################################

    subroutine DeletePedigreeFile
      implicit none
      integer(int32) :: Unit
      open(newunit=Unit, file=TESTPEDFILE, status="old")
      close(Unit, status="delete")
    end subroutine

    !###########################################################################

    subroutine CreateTinyPedNrmSubsetFile
      implicit none
      integer(int32) :: Unit
      open(newunit=Unit, file=TESTPEDNRMSUBSETFILE, action="write", status="unknown")
      write(Unit, "(a)") "B"
      write(Unit, "(a)") "D"
      write(Unit, "(a)") "F"
      close(Unit)
    end subroutine

    !###########################################################################

    subroutine DeletePedNrmSubsetFile
      implicit none
      integer(int32) :: Unit
      open(newunit=Unit, file=TESTPEDNRMSUBSETFILE, status="old")
      close(Unit, status="delete")
    end subroutine

    !###########################################################################

    @test
    subroutine TestMatchId
      implicit none
      character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
      integer(int32) :: i
      integer(int32), allocatable, dimension(:) :: RetObs, RetExp

      allocate(Id1(4))
      allocate(Id2(6))
      Id1 = ["D", "C", "A", "X"]
      Id2 = ["A", "B", "C", "D", "E", "F"]
      allocate(RetObs(4))
      allocate(RetExp(4))
      RetObs = MatchId(IdSet=Id1, IdSuperset=Id2)
      RetExp = [4, 3, 1, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
        @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 1")
      end do

      RetObs = MatchId(IdSet=Id1, IdSuperset=Id1)
      RetExp = [1, 2, 3, 4]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
        @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 2")
      end do

      deallocate(RetObs)
      deallocate(RetExp)
      allocate(RetObs(6))
      allocate(RetExp(6))
      RetObs = MatchId(IdSet=Id2, IdSuperset=Id1)
      RetExp = [3, 0, 2, 1, 0, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 6
        ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
        @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 3")
      end do

      deallocate(Id1)
      deallocate(Id2)
      deallocate(RetObs)
      deallocate(RetExp)
    end subroutine

    !###########################################################################

    @test
    subroutine TestMatchIdIndSet
      implicit none
      type(IndSet) :: x
      character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
      integer(int32) :: i
      integer(int32), allocatable, dimension(:) :: IdExp

      allocate(Id1(4))
      allocate(Id2(6))
      allocate(IdExp(4))
      Id1 = ["D", "C", "A", "X"]
      Id2 = ["A", "B", "C", "D", "E", "F"]
      call x%Init(nInd=4, OriginalId=Id1)
      call x%MatchId(OriginalIdSuperset=Id2)
      IdExp = [4, 3, 1, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
        @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 1")
      end do
      call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
      IdExp = [3, 2, 0, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
        @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 2")
      end do

      deallocate(Id2)
      allocate(Id2(0:6))
      Id2 = ["0", "A", "B", "C", "D", "E", "F"]
      call x%MatchId(OriginalIdSuperset=Id2)
      IdExp = [5, 4, 2, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
        @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 3")
      end do
      call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
      IdExp = [4, 3, 1, 0]
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
        @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 4")
      end do
      deallocate(Id1)
      deallocate(Id2)
      deallocate(IdExp)
    end subroutine

    !###########################################################################

    @test
    subroutine TestReadWriteIndSet
      implicit none
      type(IndSet) :: x, y
      integer(int32) :: i, Unit
      character(len=IDLENGTH) :: Ids(4)
      Ids = ["B", "A", "D", "C"]
      call x%Init(nInd=4, OriginalId=Ids)
      call x%Write(File="TestIndSet.txt")
      call y%Read(File="TestIndSet.txt")
      @AssertEqual(x%nInd, y%nInd, "ReadWriteIndSet broken 1")
      ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
      do i = 1, 4
        ! write(STDOUT, "(i8, a1, 2a9)") i, x%OriginalId(i), y%OriginalId(i)
        @AssertEqual(x%OriginalId(i), y%OriginalId(i), "ReadWriteIndSet broken 2")
        ! write(STDOUT, "(i8, a1, 2i9)") i, x%Id(i), y%Id(i)
        @AssertEqual(x%Id(i), y%Id(i), "ReadWriteIndSet broken 3")
      end do
      call x%Destroy
      call y%Destroy
      open(newunit=Unit, file="TestIndSet.txt", status="old")
      close(Unit, status="delete")
    end subroutine

    !###########################################################################

    @test
    subroutine TestPedInbreeding
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind
      real(real64), allocatable, dimension(:) :: CalPedInbreeding, ExpPedInbreeding

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      allocate(CalPedInbreeding(0:Data%RecPed%nInd))
      allocate(ExpPedInbreeding(0:Data%RecPed%nInd))

      CalPedInbreeding = PedInbreeding(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
      ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125, 0.125]

      ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Calculated", "Expected"
      do Ind = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), CalPedInbreeding(Ind), ExpPedInbreeding(Ind)
        @AssertEqual(CalPedInbreeding(Ind), ExpPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly - tiny example for function")
      end do
      deallocate(CalPedInbreeding)
      deallocate(ExpPedInbreeding)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! inbreeding(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestCalcPedInbreeding
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind
      real(real64), allocatable, dimension(:) :: ExpPedInbreeding

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedInbreeding

      allocate(ExpPedInbreeding(0:Data%RecPed%nInd))
      ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125, 0.125]
      ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Calculated", "Expected"
      do Ind = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), Data%PedInbreeding%Value(Ind), ExpPedInbreeding(Ind)
        @AssertEqual(Data%PedInbreeding%Value(Ind), ExpPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly - tiny example")
      end do
      deallocate(ExpPedInbreeding)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! inbreeding(Ped)

      call CreatePedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedInbreeding

      allocate(ExpPedInbreeding(0:Data%RecPed%nInd))
      ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0,   0.0,    0.0, 0.0, 0.0, 0.25,    0.25,    0.25,  0.375,    0.375,  0.375, &
                                              0.375,  0.4375, 0.5, 0.5, 0.5, 0.59375, 0.59375, 0.375, 0.484375, 0.4296875]
      ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Calculated", "Expected"
      do Ind = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), Data%PedInbreeding%Value(Ind), ExpPedInbreeding(Ind)
        @AssertEqual(Data%PedInbreeding%Value(Ind), ExpPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly - example")
      end do
      deallocate(ExpPedInbreeding)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("Porto","0","0")
      ! Ped[2, ] <- c("OldMoll","0","0")
      ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
      ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
      ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
      ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
      ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
      ! Ped[8, ] <- c("Peg","Dash1","Moll2")
      ! Ped[9, ] <- c("Rock","Pilot","Moll2")
      ! Ped[10, ] <- c("Regent","Pilot","Moll2")
      ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
      ! Ped[12, ] <- c("RockA","Peg","Rock")
      ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
      ! Ped[14, ] <- c("Rock2","Regent","Jet1")
      ! Ped[15, ] <- c("Fred1","RockA","Moll2")
      ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
      ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
      ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
      ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
      ! Ped[20, ] <- c("Dash2","Cora2","Sting")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! inbreeding(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestReadWriteInbreeding
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data, Data2
      integer(int32) :: Ind

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)
      Data2 = Data
      call Data%CalcPedInbreeding

      call Data%PedInbreeding%Write(File=TESTINBFILE, OutputFormat=Spec%OutputFormat)
      call Data2%PedInbreeding%Read(File=TESTINBFILE)

      ! write(STDOUT, "(i8, 2a16)") "Ind", "Expected", "Observed"
      do Ind = 0, Data%PedInbreeding%nInd
        ! write(STDOUT, "(i8, 2a16)") Ind, Data%PedInbreeding%OriginalId(Ind), Data2%PedInbreeding%OriginalId(Ind)
        @AssertEqual(Data%PedInbreeding%OriginalId(Ind), Data2%PedInbreeding%OriginalId(Ind), "Pedigree inbreeding original id was not written/read correctly")
      end do
      ! write(STDOUT, "(i8, a1, 2a16)") "Ind", " ", "Expected", "Observed"
      do Ind = 0, Data%PedInbreeding%nInd
        ! write(STDOUT, "(i8, a1, 2f16.8)") Ind, Data%PedInbreeding%Value(Ind), Data2%PedInbreeding%Value(Ind)
        @AssertEqual(Data%PedInbreeding%Value(Ind), Data2%PedInbreeding%Value(Ind), "Pedigree inbreeding value was not written/read correctly")
      end do

      call Data%Destroy
      call Data2%Destroy
      call DeletePedigreeFile
    end subroutine

    !###########################################################################

    @test
    subroutine TestPedNrm
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind1, Ind2
      real(real64), allocatable, dimension(:, :) :: CalPedNrm, ExpPedNrm

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      allocate(CalPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))

      CalPedNrm = PedNrm(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
      ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.00, 0.00, 0.000, 0.000, 0.0000, 0.0000, 0.0000, 0.0000] ! 0
      ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.00, 1.00, 0.000, 0.000, 0.5000, 0.5000, 0.5000, 0.2500] ! A
      ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.00, 0.00, 1.000, 0.000, 0.5000, 0.0000, 0.2500, 0.6250] ! B
      ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.00, 0.00, 0.000, 1.000, 0.0000, 0.5000, 0.2500, 0.1250] ! dum001
      ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.00, 0.50, 0.500, 0.000, 1.0000, 0.2500, 0.6250, 0.5625] ! C
      ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.00, 0.50, 0.000, 0.500, 0.2500, 1.0000, 0.6250, 0.3125] ! D
      ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.00, 0.50, 0.250, 0.250, 0.6250, 0.6250, 1.1250, 0.6875] ! E
      ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250] ! F

      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", CalPedNrm(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ", ExpPedNrm(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, CalPedNrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
          @AssertEqual(CalPedNrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM is not calculated correctly - tiny example for function")
        end do
      end do
      deallocate(CalPedNrm)
      deallocate(ExpPedNrm)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getA(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestCalcPedNrm
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind1, Ind2
      real(real64), allocatable, dimension(:, :) :: ExpPedNrm

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedNrm(Spec=Spec)

      allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      !                                      0     A      B dum001       C       D       E       F
      ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.00, 0.00, 0.000, 0.000, 0.0000, 0.0000, 0.0000, 0.0000] ! 0
      ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.00, 1.00, 0.000, 0.000, 0.5000, 0.5000, 0.5000, 0.2500] ! A
      ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.00, 0.00, 1.000, 0.000, 0.5000, 0.0000, 0.2500, 0.6250] ! B
      ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.00, 0.00, 0.000, 1.000, 0.0000, 0.5000, 0.2500, 0.1250] ! dum001
      ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.00, 0.50, 0.500, 0.000, 1.0000, 0.2500, 0.6250, 0.5625] ! C
      ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.00, 0.50, 0.000, 0.500, 0.2500, 1.0000, 0.6250, 0.3125] ! D
      ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.00, 0.50, 0.250, 0.250, 0.6250, 0.6250, 1.1250, 0.6875] ! E
      ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250] ! F
      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrm%Value(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
          @AssertEqual(Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM is not calculated correctly - tiny example")
        end do
      end do
      deallocate(ExpPedNrm)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getA(Ped)

      call CreatePedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedNrm(Spec=Spec)

      allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.0, 0.0, 0.0, 0.0000000, 0.0000000, 0.000, 0.00000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.0000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.0000000, 0.0000000, 0.0000000]
      ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.0, 1.0, 0.0, 0.5000000, 0.5000000, 0.500, 0.50000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.5000000, 0.5000000]
      ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.0, 0.0, 1.0, 0.5000000, 0.5000000, 0.500, 0.50000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.5000000, 0.5000000]
      ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.0, 0.5, 0.5, 1.0000000, 0.5000000, 0.750, 0.75000, 0.750000, 0.875000, 0.750000, 0.750000, 0.750000, 0.8125000, 0.750000, 0.750000, 0.781250, 0.750000, 0.750000, 0.7656250, 0.7656250, 0.7578125]
      ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.0, 0.5, 0.5, 0.5000000, 1.0000000, 0.750, 0.75000, 0.750000, 0.625000, 0.750000, 0.750000, 0.750000, 0.6875000, 0.750000, 0.750000, 0.718750, 0.750000, 0.750000, 0.7343750, 0.7343750, 0.7421875]
      ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 1.250, 0.75000, 0.750000, 0.750000, 0.750000, 0.750000, 0.750000, 0.7500000, 0.750000, 0.750000, 0.750000, 0.750000, 0.750000, 1.0000000, 0.7500000, 0.8750000]
      ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.25000, 0.750000, 1.000000, 1.000000, 1.000000, 1.000000, 1.0000000, 1.000000, 1.000000, 1.125000, 1.000000, 1.000000, 0.9375000, 1.0625000, 0.9687500]
      ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 0.75000, 1.250000, 0.750000, 1.000000, 1.000000, 1.000000, 0.8750000, 1.000000, 1.000000, 0.812500, 1.000000, 1.000000, 0.7812500, 0.9062500, 0.8906250]
      ExpPedNrm(0:Data%RecPed%nInd, 8) = [0.0, 0.5, 0.5, 0.8750000, 0.6250000, 0.750, 1.00000, 0.750000, 1.375000, 0.875000, 0.875000, 0.875000, 1.1250000, 0.875000, 0.875000, 1.062500, 0.875000, 0.875000, 0.9062500, 0.9687500, 0.8906250]
      ExpPedNrm(0:Data%RecPed%nInd, 9) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.375000, 1.000000, 1.000000, 1.1250000, 1.000000, 1.000000, 1.062500, 1.000000, 1.000000, 0.9062500, 1.0312500, 0.9531250]
      ExpPedNrm(0:Data%RecPed%nInd,10) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.375000, 1.000000, 0.9375000, 1.187500, 1.187500, 0.968750, 1.187500, 1.187500, 0.8593750, 1.0781250, 1.0234375]
      ExpPedNrm(0:Data%RecPed%nInd,11) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.000000, 1.375000, 0.9375000, 1.187500, 1.187500, 0.968750, 1.187500, 1.187500, 0.8593750, 1.0781250, 1.0234375]
      ExpPedNrm(0:Data%RecPed%nInd,12) = [0.0, 0.5, 0.5, 0.8125000, 0.6875000, 0.750, 1.00000, 0.875000, 1.125000, 1.125000, 0.937500, 0.937500, 1.4375000, 0.937500, 0.937500, 1.218750, 0.937500, 0.937500, 0.9843750, 1.0781250, 0.9609375]
      ExpPedNrm(0:Data%RecPed%nInd,13) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.500000, 1.187500, 0.968750, 1.343750, 1.343750, 0.8593750, 1.1562500, 1.1015625]
      ExpPedNrm(0:Data%RecPed%nInd,14) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.187500, 1.500000, 0.968750, 1.343750, 1.343750, 0.8593750, 1.1562500, 1.1015625]
      ExpPedNrm(0:Data%RecPed%nInd,15) = [0.0, 0.5, 0.5, 0.7812500, 0.7187500, 0.750, 1.12500, 0.812500, 1.062500, 1.062500, 0.968750, 0.968750, 1.2187500, 0.968750, 0.968750, 1.500000, 0.968750, 0.968750, 1.1250000, 1.2343750, 1.0468750]
      ExpPedNrm(0:Data%RecPed%nInd,16) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.343750, 1.343750, 0.968750, 1.593750, 1.343750, 0.8593750, 1.1562500, 1.2265625]
      ExpPedNrm(0:Data%RecPed%nInd,17) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.343750, 1.343750, 0.968750, 1.343750, 1.593750, 0.8593750, 1.2812500, 1.1015625]
      ExpPedNrm(0:Data%RecPed%nInd,18) = [0.0, 0.5, 0.5, 0.7656250, 0.7343750, 1.000, 0.93750, 0.781250, 0.906250, 0.906250, 0.859375, 0.859375, 0.9843750, 0.859375, 0.859375, 1.125000, 0.859375, 0.859375, 1.3750000, 0.9921875, 1.1171875]
      ExpPedNrm(0:Data%RecPed%nInd,19) = [0.0, 0.5, 0.5, 0.7656250, 0.7343750, 0.750, 1.06250, 0.906250, 0.968750, 1.031250, 1.078125, 1.078125, 1.0781250, 1.156250, 1.156250, 1.234375, 1.156250, 1.281250, 0.9921875, 1.4843750, 1.0742188]
      ExpPedNrm(0:Data%RecPed%nInd,20) = [0.0, 0.5, 0.5, 0.7578125, 0.7421875, 0.875, 0.96875, 0.890625, 0.890625, 0.953125, 1.023438, 1.023438, 0.9609375, 1.101562, 1.101562, 1.046875, 1.226562, 1.101562, 1.1171875, 1.0742188, 1.4296875]
      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrm%Value(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
          @AssertEqual(Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), 0.000001d0, "Pedigree NRM is not calculated correctly - tiny example")
        end do
      end do
      deallocate(ExpPedNrm)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("Porto","0","0")
      ! Ped[2, ] <- c("OldMoll","0","0")
      ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
      ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
      ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
      ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
      ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
      ! Ped[8, ] <- c("Peg","Dash1","Moll2")
      ! Ped[9, ] <- c("Rock","Pilot","Moll2")
      ! Ped[10, ] <- c("Regent","Pilot","Moll2")
      ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
      ! Ped[12, ] <- c("RockA","Peg","Rock")
      ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
      ! Ped[14, ] <- c("Rock2","Regent","Jet1")
      ! Ped[15, ] <- c("Fred1","RockA","Moll2")
      ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
      ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
      ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
      ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
      ! Ped[20, ] <- c("Dash2","Cora2","Sting")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getA(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestPedNrmTimesVector
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind
      real(real64), allocatable, dimension(:) :: CalPedNrmColumn, ExpPedNrmColumn, x

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      allocate(x(0:Data%RecPed%nInd))
      allocate(CalPedNrmColumn(0:Data%RecPed%nInd))
      allocate(ExpPedNrmColumn(0:Data%RecPed%nInd))

      call Data%CalcPedInbreeding()
      ! This application of PedNrmTimesVector() is to get the 7th column of Pedigree NRM
      x = [0, 0, 0, 0, 0, 0, 0, 1]
      CalPedNrmColumn = PedNrmTimesVector(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd,&
                                          Inbreeding=Data%PedInbreeding%Value,&
                                          Vector=x)
      ExpPedNrmColumn(0:Data%RecPed%nInd) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250]

      ! write(STDOUT, "(a8, 2a16)") " ", "Calculated", "Expected"
      do Ind = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, 2f16.8)") Ind, CalPedNrmColumn(Ind), ExpPedNrmColumn(Ind)
        @AssertEqual(CalPedNrmColumn(Ind), ExpPedNrmColumn(Ind), "Pedigree NRM times a vector is not calculated correctly - tiny example for function")
      end do
      deallocate(CalPedNrmColumn)
      deallocate(ExpPedNrmColumn)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getA(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestCalcPedNrmWithSubset
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind1, Ind2
      real(real64), allocatable, dimension(:, :) :: ExpPedNrm

      call CreateTinyPedigreeFile
      call CreateTinyPedNrmSubsetFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%CalcPedNrm(Spec=Spec)
      Spec%PedNrmSubsetPresent = .true.
      Spec%PedNrmSubsetFile = TESTPEDNRMSUBSETFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedNrm(Spec=Spec)
      ! call Data%PedNrm%Write(File="TestNrm2.txt", OutputFormat=Spec%OutputFormat)
      ! For individuals 0, B was 2nd now 1st, D was 5th now 2nd, F was 7th now 3rd
      allocate(ExpPedNrm(0:Data%PedNrm%nInd, 0:Data%PedNrm%nInd))
      ExpPedNrm(0:Data%PedNrm%nInd, 0) = [0.00, 0.000, 0.0000, 0.0000] ! 0
      ExpPedNrm(0:Data%PedNrm%nInd, 1) = [0.00, 1.000, 0.0000, 0.6250] ! B
      ExpPedNrm(0:Data%PedNrm%nInd, 2) = [0.00, 0.000, 1.0000, 0.3125] ! D
      ExpPedNrm(0:Data%PedNrm%nInd, 3) = [0.00, 0.625, 0.3125, 1.1250] ! F

      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%PedNrm%nInd)
      do Ind1 = 0, Data%PedNrm%nInd
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%PedNrm%OriginalId(Ind1))), "calculated", Data%PedNrm%Value(0:Data%PedNrm%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%PedNrm%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%PedNrm%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%PedNrm%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
          @AssertEqual(Data%PedNrm%Value(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM with subset is not calculated correctly")
        end do
      end do
      deallocate(ExpPedNrm)
      call Data%Destroy
      call DeletePedigreeFile
      call DeletePedNrmSubsetFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getA(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestPedNrmInv
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind1, Ind2
      real(real64), allocatable, dimension(:, :) :: CalPedNrmInv, ExpPedNrmInv

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      allocate(CalPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))

      call Data%CalcPedInbreeding()
      CalPedNrmInv = PedNrmInv(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd, Inbreeding=Data%PedInbreeding%Value)
      ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  0.5000000,  0.5, -1.0, -1.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  0.5,  2.0333333,  0.0, -1.0,  0.0,  0.5333333, -1.066667]
      ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0,  0.5,  0.0000000,  1.5,  0.0, -1.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0000000,  0.0,  2.5,  0.5, -1.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0, -1.0,  0.0000000, -1.0,  0.5,  2.5, -1.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.5333333,  0.0, -1.0, -1.0,  2.5333333, -1.066667]
      ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0, -1.0666667,  0.0,  0.0,  0.0, -1.0666667,  2.133333]

      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", CalPedNrmInv(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ", ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, CalPedNrmInv(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
          @AssertEqual(CalPedNrmInv(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example for function")
        end do
      end do
      deallocate(CalPedNrmInv)
      deallocate(ExpPedNrmInv)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getAInv(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestCalcPedNrmInv
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data
      integer(int32) :: Ind1, Ind2
      real(real64), allocatable, dimension(:, :) :: ExpPedNrmInv

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedNrmInv

      allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  0.5000000,  0.5, -1.0, -1.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  0.5,  2.0333333,  0.0, -1.0,  0.0,  0.5333333, -1.066667]
      ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0,  0.5,  0.0000000,  1.5,  0.0, -1.0,  0.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0000000,  0.0,  2.5,  0.5, -1.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0, -1.0,  0.0000000, -1.0,  0.5,  2.5, -1.0000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.5333333,  0.0, -1.0, -1.0,  2.5333333, -1.066667]
      ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0, -1.0666667,  0.0,  0.0,  0.0, -1.0666667,  2.133333]
      ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrmInv%Value(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrmInv%Value(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
          @AssertEqual(Data%PedNrmInv%Value(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example")
        end do
      end do
      deallocate(ExpPedNrmInv)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("A","0","0")
      ! Ped[2, ] <- c("B","0","0")
      ! Ped[3, ] <- c("dum001","0","0")
      ! Ped[4, ] <- c("C","A","B")
      ! Ped[5, ] <- c("D","A","dum001")
      ! Ped[6, ] <- c("E","D","C")
      ! Ped[7, ] <- c("F","E","B")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getAInv(Ped)

      call CreatePedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)

      call Data%CalcPedNrmInv

      allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
      ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  1.0, -1.0000000, -1.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  1.0,  2.0, -1.0000000, -1.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0, -1.0, -1.0,  4.0714286,  1.5, -1.0, -0.4285714, -1.000000, -1.142857,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0,  1.5000000,  3.5, -1.0, -1.0000000, -1.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0,  0.0,  0.0, -1.0000000, -1.0,  2.8,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.800000,  0.000000,  0.000000, -1.600000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.0, -0.4285714, -1.0,  0.0,  5.3333333,  2.000000, -1.142857, -1.333333, -1.333333, -1.333333,  0.7619048,  0.0,  0.0, -1.523810,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0,  0.0, -1.0000000, -1.0,  0.0,  2.0000000,  4.000000,  0.000000, -1.333333, -1.333333, -1.333333,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 8) = [0.0,  0.0,  0.0, -1.1428571,  0.0,  0.0, -1.1428571,  0.000000,  3.085714,  0.800000,  0.000000,  0.000000, -1.6000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd, 9) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.800000,  3.466667,  0.000000,  0.000000, -1.6000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,10) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.000000,  0.000000,  4.266667,  1.600000,  0.0000000, -1.6, -1.6,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,11) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.000000,  0.000000,  1.600000,  4.266667,  0.0000000, -1.6, -1.6,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,12) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.7619048,  0.000000, -1.600000, -1.600000,  0.000000,  0.000000,  3.9619048,  0.0,  0.0, -1.523810,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,13) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000, -1.600000, -1.600000,  0.0000000,  5.2,  2.0,  0.000000, -2.000000, -2.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,14) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000, -1.600000, -1.600000,  0.0000000,  2.0,  5.2,  0.000000, -2.000000, -2.000000,  0.000000,  0.000000,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,15) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.8, -1.5238095,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000, -1.5238095,  0.0,  0.0,  4.951067,  0.000000,  1.103448, -1.600000, -2.206897,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,16) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000, -2.0, -2.0,  0.000000,  4.969697,  0.000000,  0.969697,  0.000000, -1.939394]
      ExpPedNrmInv(0:Data%RecPed%nInd,17) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000, -2.0, -2.0,  1.103448,  0.000000,  5.103448,  0.000000, -2.206897,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,18) = [0.0,  0.0,  0.0,  0.0000000,  0.0, -1.6,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0, -1.600000,  0.969697,  0.000000,  4.169697,  0.000000, -1.939394]
      ExpPedNrmInv(0:Data%RecPed%nInd,19) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0, -2.206897,  0.000000, -2.206897,  0.000000,  4.413793,  0.000000]
      ExpPedNrmInv(0:Data%RecPed%nInd,20) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000, -1.939394,  0.000000, -1.939394,  0.000000,  3.878788]
      ! write(STDOUT, "(a9, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
      do Ind1 = 0, Data%RecPed%nInd
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrmInv%Value(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
        ! write(STDOUT, "(a)") ""
        ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
        do Ind2 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrmInv%Value(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
          @AssertEqual(Data%PedNrmInv%Value(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example")
        end do
      end do
      deallocate(ExpPedNrmInv)
      call Data%Destroy
      call DeletePedigreeFile
      ! R code to test using the pedigreemm package
      ! library(pedigreemm)
      ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
      ! Ped[1, ] <- c("Porto","0","0")
      ! Ped[2, ] <- c("OldMoll","0","0")
      ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
      ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
      ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
      ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
      ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
      ! Ped[8, ] <- c("Peg","Dash1","Moll2")
      ! Ped[9, ] <- c("Rock","Pilot","Moll2")
      ! Ped[10, ] <- c("Regent","Pilot","Moll2")
      ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
      ! Ped[12, ] <- c("RockA","Peg","Rock")
      ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
      ! Ped[14, ] <- c("Rock2","Regent","Jet1")
      ! Ped[15, ] <- c("Fred1","RockA","Moll2")
      ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
      ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
      ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
      ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
      ! Ped[20, ] <- c("Dash2","Cora2","Sting")
      ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
      ! getAInv(Ped)
    end subroutine

    !###########################################################################

    @test
    subroutine TestWriteReadNrm
      implicit none
      type(AlphaRelateSpec) :: Spec
      type(AlphaRelateData) :: Data, Data2
      integer(int32) :: Ind1, Ind2, i, Unit
      logical :: Ija(2)

      call CreateTinyPedigreeFile
      call Spec%Init
      Spec%PedigreePresent = .true.
      Spec%PedigreeFile = TESTPEDFILE
      call Data%Init(Spec=Spec)
      Data2 = Data
      call Data%CalcPedNrm(Spec=Spec)

      Ija(1:2) = [.false., .true.]
      do i = 1, 2
        Spec%PedNrmIja = Ija(i)
        call Data%PedNrm%Write(File=TESTNRMFILE, OutputFormat=Spec%OutputFormat, Ija=Ija(i))
        call Data2%PedNrm%Read(File=TESTNRMFILE, Ija=Ija(i))

        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1=0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data2%RecPed%OriginalId(Ind1))), "observed",  Data2%PedNrm%Value(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))),  "expected",   Data%PedNrm%Value(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          @AssertEqual(Data%RecPed%OriginalId(Ind1), Data2%RecPed%OriginalId(Ind1), "Pedigree NRM original Id were not written/read correctly with Ija="//Log2Char(Ija(i)))
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Observed", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Nrm(Ind2, Ind1), Data%PedNrm%Value(Ind2, Ind1)
            @AssertEqual(Data%PedNrm%Value(Ind2, Ind1), Data2%PedNrm%Value(Ind2, Ind1), "Pedigree NRM values were not written/read correctly with Ija="//Log2Char(Ija(i)))
          end do
        end do
      end do

      call Data%Destroy
      call Data2%Destroy
      call DeletePedigreeFile
      open(newunit=Unit, file=TESTNRMFILE, status="old")
      close(Unit, status="delete")
      open(newunit=Unit, file=trim(TESTNRMFILE)//"_IdMap", status="old")
      close(Unit, status="delete")
    end subroutine

    !###########################################################################

    ! @test
    ! subroutine TestMakeGMatrixNejatiJavaremi
    !   implicit none

    !   real(real64), allocatable :: GMatTarget(:, :, :)

    !   ! Setup
    !   nAnisG = 3
    !   nSnp = 1
    !   allocate(Genos(nAnisG, nSnp))
    !   allocate(GMat(nAnisG, nAnisG, 1))
    !   allocate(GMatTarget(nAnisG, nAnisG, 1))

    !   !GType = "Nejati-Javaremi"

    !   ! Simple example
    !   Genos(1, :) = 0
    !   Genos(2, :) = 1
    !   Genos(3, :) = 2

    !   !GMatTarget(1, :, 1) = [2.0d0, 1.0d0, 0.0d0]
    !   !GMatTarget(2, :, 1) = [1.0d0, 1.0d0, 1.0d0]
    !   !GMatTarget(3, :, 1) = [0.0d0, 1.0d0, 2.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Nejati-Javaremi for the first marker is not correct")

    !   ! Another simple example
    !   Genos(1, :) = 1
    !   Genos(2, :) = 2
    !   Genos(3, :) = 1

    !   !GMatTarget(1, :, 1) = [1.0d0, 1.0d0, 1.0d0]
    !   !GMatTarget(2, :, 1) = [1.0d0, 2.0d0, 1.0d0]
    !   !GMatTarget(3, :, 1) = [1.0d0, 1.0d0, 1.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Nejati-Javaremi for the second marker is not correct")

    !   ! Combine the above two simple examples
    !   deallocate(Genos)
    !   nSnp = 2
    !   allocate(Genos(nAnisG, nSnp))

    !   Genos(1, :) = [0, 1]
    !   Genos(2, :) = [1, 2]
    !   Genos(3, :) = [2, 1]

    !   !GMatTarget(1, :, 1) = [1.5d0, 1.0d0, 0.5d0]
    !   !GMatTarget(2, :, 1) = [1.0d0, 1.5d0, 1.0d0]
    !   !GMatTarget(3, :, 1) = [0.5d0, 1.0d0, 1.5d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Nejati-Javaremi for the two markers is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 1.00d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Nejati-Javaremi with equal weights is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 0.50d0]

    !   !GMatTarget(1, :, 1) = [1.25d0, 0.75d0, 0.25d0]
    !   !GMatTarget(2, :, 1) = [0.75d0, 1.00d0, 0.75d0]
    !   !GMatTarget(3, :, 1) = [0.25d0, 0.75d0, 1.25d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Nejati-Javaremi with variable weights is not correct")
    ! end subroutine

    !###########################################################################

    ! @test
    ! subroutine TestMakeGMatrixVanRaden1
    !   implicit none

    !   real(real64), allocatable :: GMatTarget(:, :, :)

    !   ! Setup
    !   nAnisG = 3
    !   nSnp = 1
    !   allocate(Genos(nAnisG, nSnp))
    !   allocate(GMat(nAnisG, nAnisG, 1))
    !   allocate(GMatTarget(nAnisG, nAnisG, 1))

    !   !GType = "VanRaden"

    !   ! Simple example
    !   Genos(1, :) = 0
    !   Genos(2, :) = 1
    !   Genos(3, :) = 2

    !   !GMatTarget(1, :, 1) = [ 2.0d0, 0.0d0, -2.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 0.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-2.0d0, 0.0d0,  2.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 for the first marker is not correct")

    !   ! Another simple example
    !   Genos(1, :) = 1
    !   Genos(2, :) = 2
    !   Genos(3, :) = 1

    !   !GMatTarget(1, :, 1) = [ 0.25d0, -0.5d0,  0.25d0]
    !   !GMatTarget(2, :, 1) = [-0.50d0,  1.0d0, -0.50d0]
    !   !GMatTarget(3, :, 1) = [ 0.25d0, -0.5d0,  0.25d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 for the second marker is not correct")

    !   ! Combine the above two simple examples
    !   deallocate(Genos)
    !   nSnp = 2
    !   allocate(Genos(nAnisG, nSnp))

    !   Genos(1, :) = [0, 1]
    !   Genos(2, :) = [1, 2]
    !   Genos(3, :) = [2, 1]

    !   !GMatTarget(1, :, 1) = [ 20.0d0, -4.0d0, -16.0d0]
    !   !GMatTarget(2, :, 1) = [ -4.0d0,  8.0d0,  -4.0d0]
    !   !GMatTarget(3, :, 1) = [-16.0d0, -4.0d0,  20.0d0]
    !   !GMatTarget(:, :, 1) = GMatTarget(:, :, 1) / 17.0d0

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 for the two markers is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 1.00d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 with equal weights is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 0.50d0]

    !   !GMatTarget(1, :, 1) = [ 19.0d0, -2.0d0, -17.0d0]
    !   !GMatTarget(2, :, 1) = [ -2.0d0,  4.0d0,  -2.0d0]
    !   !GMatTarget(3, :, 1) = [-17.0d0, -2.0d0,  19.0d0]
    !   !GMatTarget(:, :, 1) = GMatTarget(:, :, 1) / 17.0d0

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 with variable weights is not correct")

    !   !WeightsPresent = .false.
    !   AlleleFreq(:) = [0.5d0, 0.5d0]

    !   !GMatTarget(1, :, 1) = [ 1.0d0, 0.0d0, -1.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 1.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-1.0d0, 0.0d0,  1.0d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 1 with given/fixed allele frequencies is not correct")
    ! end subroutine

    !###########################################################################

    ! @test
    ! subroutine TestMakeGMatrixVanRaden2
    !   implicit none

    !   real(real64), allocatable :: GMatTarget(:, :, :)

    !   ! Setup
    !   nAnisG = 3
    !   nSnp = 1
    !   allocate(Genos(nAnisG, nSnp))
    !   allocate(GMat(nAnisG, nAnisG, 1))
    !   allocate(GMatTarget(nAnisG, nAnisG, 1))

    !   !GType = "VanRaden2"

    !   ! Simple example
    !   Genos(1, :) = 0
    !   Genos(2, :) = 1
    !   Genos(3, :) = 2

    !   !GMatTarget(1, :, 1) = [ 2.0d0, 0.0d0, -2.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 0.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-2.0d0, 0.0d0,  2.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 for the first marker is not correct")

    !   ! Another simple example
    !   Genos(1, :) = 1
    !   Genos(2, :) = 2
    !   Genos(3, :) = 1

    !   !GMatTarget(1, :, 1) = [ 0.25d0, -0.5d0,  0.25d0]
    !   !GMatTarget(2, :, 1) = [-0.50d0,  1.0d0, -0.50d0]
    !   !GMatTarget(3, :, 1) = [ 0.25d0, -0.5d0,  0.25d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 for the second marker is not correct")

    !   ! Combine the above two simple examples
    !   deallocate(Genos)
    !   nSnp = 2
    !   allocate(Genos(nAnisG, nSnp))

    !   Genos(1, :) = [0, 1]
    !   Genos(2, :) = [1, 2]
    !   Genos(3, :) = [2, 1]

    !   !GMatTarget(1, :, 1) = [ 1.125d0, -0.25d0, -0.875d0]
    !   !GMatTarget(2, :, 1) = [-0.250d0,  0.50d0, -0.250d0]
    !   !GMatTarget(3, :, 1) = [-0.875d0, -0.25d0,  1.125d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 for the two markers is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 1.00d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 with equal weights is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 0.50d0]

    !   !GMatTarget(1, :, 1) = [ 1.0625d0, -0.125d0, -0.9375d0]
    !   !GMatTarget(2, :, 1) = [-0.1250d0,  0.250d0, -0.1250d0]
    !   !GMatTarget(3, :, 1) = [-0.9375d0, -0.125d0,  1.0625d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 with variable weights is not correct")

    !   !WeightsPresent = .false.
    !   AlleleFreq(:) = [0.5d0, 0.5d0]

    !   !GMatTarget(1, :, 1) = [ 1.0d0, 0.0d0, -1.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 1.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-1.0d0, 0.0d0,  1.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 with given/fixed allele frequencies is not correct")
    ! end subroutine

    !###########################################################################

    ! @test
    ! subroutine TestMakeGMatrixYang
    !   implicit none

    !   real(real64), allocatable :: GMatTarget(:, :, :)

    !   ! Setup
    !   nAnisG = 3
    !   nSnp = 1
    !   allocate(Genos(nAnisG, nSnp))
    !   allocate(GMat(nAnisG, nAnisG, 1))
    !   allocate(GMatTarget(nAnisG, nAnisG, 1))

    !   !GType = "Yang"

    !   ! Simple example
    !   Genos(1, :) = 0
    !   Genos(2, :) = 1
    !   Genos(3, :) = 2

    !   !GMatTarget(1, :, 1) = [ 2.0d0, 0.0d0, -2.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 0.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-2.0d0, 0.0d0,  2.0d0]

    !   !call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Yang for the first marker is not correct")

    !   ! Another simple example
    !   Genos(1, :) = 1
    !   Genos(2, :) = 2
    !   Genos(3, :) = 1

    !   !GMatTarget(1, :, 1) = [ 0.00d0, -0.5d0,  0.25d0]
    !   !GMatTarget(2, :, 1) = [-0.50d0,  1.5d0, -0.50d0]
    !   !GMatTarget(3, :, 1) = [ 0.25d0, -0.5d0,  0.00d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Yang for the second marker is not correct")

    !   ! Combine the above two simple examples
    !   deallocate(Genos)
    !   nSnp = 2
    !   allocate(Genos(nAnisG, nSnp))

    !   Genos(1, :) = [0, 1]
    !   Genos(2, :) = [1, 2]
    !   Genos(3, :) = [2, 1]

    !   !GMatTarget(1, :, 1) = [ 1.000d0, -0.25d0, -0.875d0]
    !   !GMatTarget(2, :, 1) = [-0.250d0,  0.75d0, -0.250d0]
    !   !GMatTarget(3, :, 1) = [-0.875d0, -0.25d0,  1.000d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Yang for the two markers is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 1.00d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Yang with equal weights is not correct")

    !   !WeightsPresent = .true.
    !   !Weights(:, 1) = [1.0d0, 0.50d0]

    !   !GMatTarget(1, :, 1) = [ 1.0000d0, -0.125d0, -0.9375d0]
    !   !GMatTarget(2, :, 1) = [-0.1250d0,  0.375d0, -0.1250d0]
    !   !GMatTarget(3, :, 1) = [-0.9375d0, -0.125d0,  1.0000d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - VanRaden type 2 with variable weights is not correct")

    !   !WeightsPresent = .false.
    !   AlleleFreq(:) = [0.5d0, 0.5d0]

    !   !GMatTarget(1, :, 1) = [ 1.0d0, 0.0d0, -1.0d0]
    !   !GMatTarget(2, :, 1) = [ 0.0d0, 1.0d0,  0.0d0]
    !   !GMatTarget(3, :, 1) = [-1.0d0, 0.0d0,  1.0d0]

    !   call MakeGAndInvGMatrix

    !   @assertEqual(GMat, GMatTarget, "Genomic NRM - Yang with given/fixed allele frequencies is not correct")
    ! end subroutine

    !###########################################################################

end module

!###############################################################################
