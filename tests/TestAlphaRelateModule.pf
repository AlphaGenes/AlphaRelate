
!###############################################################################

module TestAlphaRelateModule
  use ISO_Fortran_env, STDOUT => output_unit
  use pFUnit_mod
  use ConstantModule, only : IDLENGTH
  use AlphaHouseMod, only : Int2Char, Log2Char
  use AlphaRelateModule

  implicit none

  CHARACTER(len=100), PARAMETER :: TESTPEDFILE = "TestPedigree.txt"
  CHARACTER(len=100), PARAMETER :: TESTPEDINBFILE = "TestPedInb.txt"
  CHARACTER(len=100), PARAMETER :: TESTPEDNRMFILE = "TestPedNrm.txt"
  CHARACTER(len=100), PARAMETER :: TESTPEDNRMSUBSETFILE = "TestPedNrmSubset.txt"

  CHARACTER(len=100), PARAMETER :: TESTGENFILE = "TestGenotype.txt"

  CHARACTER(len=100), PARAMETER :: TESTAFFILE = "TestAlleleFreq.txt"
  CHARACTER(len=100), PARAMETER :: TESTLWFILE = "TestLocusWeight.txt"

  contains

    !###########################################################################

    @before
    subroutine Setup
      implicit none
    end subroutine

    !###########################################################################

    @after
    subroutine Finish
      implicit none
    end subroutine

    !###########################################################################

    ! Files

      !#########################################################################

      subroutine CreateTinyPedigreeFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTPEDFILE, action="write", status="unknown")
        ! From the Mrode's book (2014)
        write(Unit, "(a)") "A 0 0"
        write(Unit, "(a)") "B 0 0"
        write(Unit, "(a)") "C A B"
        write(Unit, "(a)") "D A 0"
        write(Unit, "(a)") "E D C"
        write(Unit, "(a)") "F E B"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine CreatePedigreeFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTPEDFILE, action="write", status="unknown")
        ! From Garcia-Cortes et al. (2013) http://dx.doi.org/10.1371/journal.pone.0057003
        write(Unit, "(a)") "Porto 0 0"
        write(Unit, "(a)") "OldMoll 0 0"
        write(Unit, "(a)") "Dash1 Porto OldMoll"
        write(Unit, "(a)") "Belle1 Porto OldMoll"
        write(Unit, "(a)") "Cora1 Dash1 Belle1"
        write(Unit, "(a)") "Moll2 Dash1 Belle1"
        write(Unit, "(a)") "Pilot Dash1 Belle1"
        write(Unit, "(a)") "Peg Dash1 Moll2"
        write(Unit, "(a)") "Rock Pilot Moll2"
        write(Unit, "(a)") "Regent Pilot Moll2"
        write(Unit, "(a)") "Jet1 Pilot Moll2"
        write(Unit, "(a)") "RockA Peg Rock"
        write(Unit, "(a)") "CoraBlairs Regent Jet1"
        write(Unit, "(a)") "Rock2 Regent Jet1"
        write(Unit, "(a)") "Fred1 RockA Moll2"
        write(Unit, "(a)") "Sting CoraBlairs Rock2"
        write(Unit, "(a)") "Belle2 CoraBlairs Rock2"
        write(Unit, "(a)") "Cora2 Cora1 Fred1"
        write(Unit, "(a)") "Moll3 Fred1 Belle2"
        write(Unit, "(a)") "Dash2 Cora2 Sting"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine DeletePedigreeFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTPEDFILE, status="old")
        close(Unit, status="delete")
        open(newunit=Unit, file=trim(TESTPEDFILE)//"_Recoded.txt", status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      subroutine CreateTinyPedNrmSubsetFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTPEDNRMSUBSETFILE, action="write", status="unknown")
        write(Unit, "(a)") "B"
        write(Unit, "(a)") "D"
        write(Unit, "(a)") "F"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine DeletePedNrmSubsetFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTPEDNRMSUBSETFILE, status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      subroutine CreateTinyGenotypeFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTGENFILE, action="write", status="unknown")
        write(Unit, "(a)") "B 0 1"
        write(Unit, "(a)") "D 1 2"
        write(Unit, "(a)") "E 2 1"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine CreateTinyGenotypeFileWithMissing
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTGENFILE, action="write", status="unknown")
        write(Unit, "(a)") "B 0 1 2 9"
        write(Unit, "(a)") "D 1 2 9 9"
        write(Unit, "(a)") "E 2 1 9 9"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine DeleteGenotypeFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTGENFILE, status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      subroutine CreateAlleleFreqFileForTinyGenotypeFileWithMissing
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTAFFILE, action="write", status="unknown")
        write(Unit, "(a)") "2 0.666666666" ! order swapped on purpose
        write(Unit, "(a)") "1 0.500000000" ! order swapped on purpose
        write(Unit, "(a)") "3 1.000000000"
        write(Unit, "(a)") "4 0.000000000"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine DeleteAlleleFreqFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTAFFILE, status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      subroutine CreateLocusWeightFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTLWFILE, action="write", status="unknown")
        write(Unit, "(a)") "2 2.0" ! order swapped on purpose
        write(Unit, "(a)") "1 1.0" ! order swapped on purpose
        write(Unit, "(a)") "3 1.0"
        write(Unit, "(a)") "4 0.0"
        close(Unit)
      end subroutine

      !#########################################################################

      subroutine DeleteLocusWeightFile
        implicit none
        integer(int32) :: Unit
        open(newunit=Unit, file=TESTLWFILE, status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

    !###########################################################################

    ! IndSet type tests

      !#########################################################################

      @test
      subroutine TestMatchId
        implicit none
        character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
        integer(int32) :: i
        integer(int32), allocatable, dimension(:) :: RetObs, RetExp

        allocate(Id1(4))
        allocate(Id2(6))
        Id1 = ["D", "C", "A", "X"]
        Id2 = ["A", "B", "C", "D", "E", "F"]
        allocate(RetObs(4))
        allocate(RetExp(4))
        RetObs = MatchId(IdSet=Id1, IdSuperset=Id2)
        RetExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
          @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 1")
        end do

        RetObs = MatchId(IdSet=Id1, IdSuperset=Id1)
        RetExp = [1, 2, 3, 4]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
          @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 2")
        end do

        deallocate(RetObs)
        deallocate(RetExp)
        allocate(RetObs(6))
        allocate(RetExp(6))
        RetObs = MatchId(IdSet=Id2, IdSuperset=Id1)
        RetExp = [3, 0, 2, 1, 0, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 6
          ! write(STDOUT, "(i8, a1, 2i9)") i, RetObs(i), RetExp(i)
          @AssertEqual(RetObs(i), RetExp(i), "MatchId broken 3")
        end do

        deallocate(Id1)
        deallocate(Id2)
        deallocate(RetObs)
        deallocate(RetExp)
      end subroutine

      !#########################################################################

      @test
      subroutine TestMatchIdIndSet
        implicit none
        type(IndSet) :: x
        character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
        integer(int32) :: i
        integer(int32), allocatable, dimension(:) :: IdExp

        allocate(Id1(4))
        allocate(Id2(6))
        allocate(IdExp(4))
        Id1 = ["D", "C", "A", "X"]
        Id2 = ["A", "B", "C", "D", "E", "F"]
        call x%Init(nInd=4, OriginalId=Id1)
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 1")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 1b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [3, 2, 0, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 2")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 2b")
        end do

        deallocate(Id2)
        allocate(Id2(0:6))
        Id2 = ["0", "A", "B", "C", "D", "E", "F"]
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [5, 4, 2, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 3")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 3b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 4")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdIndSet broken 4b")
        end do
        deallocate(Id1)
        deallocate(Id2)
        deallocate(IdExp)
      end subroutine

      !#########################################################################

      @test
      subroutine TestReadWriteIndSet
        implicit none
        type(IndSet) :: x, y
        integer(int32) :: i, Unit
        character(len=IDLENGTH) :: Ids(4)
        Ids = ["B", "A", "D", "C"]
        call x%Init(nInd=4, OriginalId=Ids)
        call x%Write(File="TestIndSet.txt")
        call y%Read(File="TestIndSet.txt")
        @AssertEqual(x%nInd, y%nInd, "ReadWriteIndSet broken 1")
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2a9)") i, x%OriginalId(i), y%OriginalId(i)
          @AssertEqual(x%OriginalId(i), y%OriginalId(i), "ReadWriteIndSet broken 2")
          ! write(STDOUT, "(i8, a1, 2i9)") i, x%Id(i), y%Id(i)
          @AssertEqual(x%Id(i), y%Id(i), "ReadWriteIndSet broken 3")
        end do
        call x%Destroy
        call y%Destroy
        open(newunit=Unit, file="TestIndSet.txt", status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

    !###########################################################################

    ! AlleleFreq type tests

      !#########################################################################

      @test
      subroutine TestWriteReadAlleleFreq
        implicit none
        type(AlleleFreq) :: AF, AF2
        integer(int32) :: Loc, Unit

        call CreateAlleleFreqFileForTinyGenotypeFileWithMissing
        call AF%Read(File=TESTAFFILE)
        call AF%Write(File=trim(TESTAFFILE)//"2")
        call AF2%Read(File=trim(TESTAFFILE)//"2")

        @AssertEqual(AF%nLoc, AF2%nLoc, "AlleleFreq nLoc were not assigned correctly")
        do Loc = 1, AF%nLoc
          ! write(STDOUT, "(a8, 2a10)") " ", "Expected", "Observed"
          ! write(STDOUT, "(i8, 2f10.7)") Loc, AF%Value(Loc), AF2%Value(Loc)
          @AssertEqual(AF%Value(Loc), AF2%Value(Loc), "AlleleFreq values were not written/read correctly")
        end do

        call AF%Destroy
        call AF2%Destroy
        call DeleteAlleleFreqFile
        open(newunit=Unit, file=trim(TESTAFFILE)//"2", status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

    !###########################################################################

    ! LocusWeight type tests

      !#########################################################################

      @test
      subroutine TestWriteReadLocusWeight
        implicit none
        type(LocusWeight) :: LW, LW2
        integer(int32) :: Loc, Unit

        call CreateLocusWeightFile
        call LW%Read(File=TESTLWFILE)
        call LW%Write(File=trim(TESTLWFILE)//"2")
        call LW2%Read(File=trim(TESTLWFILE)//"2")

        @AssertEqual(LW%nLoc, LW2%nLoc, "LocusWeight nLoc were not assigned correctly")
        do Loc = 1, LW%nLoc
          ! write(STDOUT, "(a8, 2a10)") " ", "Expected", "Observed"
          ! write(STDOUT, "(i8, 2f10.7)") Loc, AF%Value(Loc), AF2%Value(Loc)
          @AssertEqual(LW%Value(Loc), LW2%Value(Loc), "LocusWeight values were not written/read correctly")
        end do

        call LW%Destroy
        call LW2%Destroy
        call DeleteLocusWeightFile
        open(newunit=Unit, file=trim(TESTLWFILE)//"2", status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

    !###########################################################################

    ! Genotype array type tests

      !#########################################################################

      @test
      subroutine TestWriteReadGenotypeArray
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data, Data2
        integer(int32) :: Ind, Loc
        integer(int32), allocatable, dimension(:) :: GenotypeExp, GenotypeObs

        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 2
        call Data%Read(Spec=Spec)
        call Data%Gen%Write(File=TESTGENFILE)

        Data2 = Data
        call Data2%Gen%Read(File=TESTGENFILE, nLoc=Spec%nLoc)

        allocate(GenotypeExp(Spec%nLoc))
        allocate(GenotypeObs(Spec%nLoc))

        @AssertEqual(Data%Gen%nInd, Data2%Gen%nInd, "Genotype array nInd were not assigned correctly")
        @AssertEqual(Data%Gen%nLoc, Data2%Gen%nLoc, "Genotype array nLoc were not assigned correctly")
        do Ind = 0, Data%Gen%nInd
          ! write(STDOUT, "(a8, 2a16)") " ", "Observed", "Expected"
          ! write(STDOUT, "(i8, 2a16)") Ind, Data%Gen%OriginalId(Ind), Data2%Gen%OriginalId(Ind)
          @AssertEqual(Data%Gen%OriginalId(Ind), Data2%Gen%OriginalId(Ind), "Genotype array original Id were not written/read correctly")
          ! write(STDOUT, "(a8, 2a16)") " ", "Observed", "Expected"
          ! write(STDOUT, "(i8, 2a16)") Ind, Data%Gen%Id(Ind), Data2%Gen%Id(Ind)
          @AssertEqual(Data%Gen%Id(Ind),         Data2%Gen%Id(Ind),         "Genotype array          Id were not assigned     correctly")
          ! write(STDOUT, "(2a8, 2a16)") " ", "Locus", "Observed", "Expected"
          GenotypeExp = int(Data%Gen%Genotype(Ind)%ToIntegerArray(), kind=int32)  ! int() because AssertEqual does not work with int8
          GenotypeObs = int(Data2%Gen%Genotype(Ind)%ToIntegerArray(), kind=int32) ! int() because AssertEqual does not work with int8
          do Loc = 1, Spec%nLoc
            ! write(STDOUT, "(4i8, i8)") Ind, Loc, GenotypeExp(Loc), GenotypeObs(Loc)
            @AssertEqual(GenotypeExp(Loc), GenotypeObs(Loc),   "Genotype array   genotypes were not written/read correctly")
          end do
        end do

        deallocate(GenotypeExp)
        deallocate(GenotypeObs)
        call Data%Destroy
        call Data2%Destroy
        call DeleteGenotypeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestMatchIdGenotypeArray
        implicit none
        type(GenotypeArray) :: x
        character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
        integer(int32) :: i
        integer(int32), allocatable, dimension(:) :: IdExp

        allocate(Id1(4))
        allocate(Id2(6))
        allocate(IdExp(4))
        Id1 = ["D", "C", "A", "X"]
        Id2 = ["A", "B", "C", "D", "E", "F"]
        call x%Init(nInd=4, nLoc=1, OriginalId=Id1)
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 1")
        end do
        call x%Init(nInd=4, nLoc=1, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 1b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [3, 2, 0, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 2")
        end do
        call x%Init(nInd=4, nLoc=1, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 2b")
        end do

        deallocate(Id2)
        allocate(Id2(0:6))
        Id2 = ["0", "A", "B", "C", "D", "E", "F"]
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [5, 4, 2, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 3")
        end do
        call x%Init(nInd=4, nLoc=1, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 3b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 4")
        end do
        call x%Init(nInd=4, nLoc=1, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdGenotypeArray broken 4b")
        end do
        deallocate(Id1)
        deallocate(Id2)
        deallocate(IdExp)
      end subroutine

      !#########################################################################

    !###########################################################################

    ! Inbreeding type tests

      !#########################################################################

      @test
      subroutine TestReadWriteInbreeding
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data, Data2
        integer(int32) :: Ind, Unit

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)
        Data2 = Data
        call Data%CalcPedInbreeding

        call Data%PedInbreeding%Write(File=TESTPEDINBFILE, OutputFormat=Spec%OutputFormat)
        call Data2%PedInbreeding%Read(File=TESTPEDINBFILE)

        @AssertEqual(Data%PedInbreeding%nInd, Data2%PedInbreeding%nInd, "Pedigree inbreeding nInd were not assigned correctly")
        ! write(STDOUT, "(i8, 2a16)") "Ind", "Expected", "Observed"
        do Ind = 0, Data%PedInbreeding%nInd
          ! write(STDOUT, "(i8, 2a16)") Ind, Data%PedInbreeding%OriginalId(Ind), Data2%PedInbreeding%OriginalId(Ind)
          @AssertEqual(Data%PedInbreeding%OriginalId(Ind), Data2%PedInbreeding%OriginalId(Ind), "Pedigree inbreeding original id was not written/read correctly")
        end do
        ! write(STDOUT, "(i8, a1, 2a16)") "Ind", " ", "Expected", "Observed"
        do Ind = 0, Data%PedInbreeding%nInd
          ! write(STDOUT, "(i8, a1, 2f16.8)") Ind, Data%PedInbreeding%Inb(Ind), Data2%PedInbreeding%Inb(Ind)
          @AssertEqual(Data%PedInbreeding%Inb(Ind), Data2%PedInbreeding%Inb(Ind), "Pedigree inbreeding value was not written/read correctly")
        end do

        call Data%Destroy
        call Data2%Destroy
        call DeletePedigreeFile
        open(newunit=Unit, file=TESTPEDINBFILE, status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      @test
      subroutine TestMatchInbreeding
        implicit none
        type(Inbreeding) :: x
        character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
        integer(int32) :: i
        integer(int32), allocatable, dimension(:) :: IdExp

        allocate(Id1(4))
        allocate(Id2(6))
        allocate(IdExp(4))
        Id1 = ["D", "C", "A", "X"]
        Id2 = ["A", "B", "C", "D", "E", "F"]
        call x%Init(nInd=4, OriginalId=Id1)
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 1")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 1b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [3, 2, 0, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 2")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 2b")
        end do

        deallocate(Id2)
        allocate(Id2(0:6))
        Id2 = ["0", "A", "B", "C", "D", "E", "F"]
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [5, 4, 2, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 3")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 3b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 4")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchInbreeding broken 4b")
        end do
        deallocate(Id1)
        deallocate(Id2)
        deallocate(IdExp)
      end subroutine

      !#########################################################################

    !###########################################################################

    ! Nrm type tests

      !#########################################################################

      @test
      subroutine TestWriteReadNrm
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data, Data2
        integer(int32) :: Ind1, Ind2, i, Unit
        logical :: Ija(2)

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)
        Data2 = Data
        call Data%CalcPedNrm(Spec=Spec)

        Ija(1:2) = [.false., .true.]
        do i = 1, 2
          Spec%PedNrmIja = Ija(i)
          call Data%PedNrm%Write(File=TESTPEDNRMFILE, OutputFormat=Spec%OutputFormat, Ija=Ija(i))
          call Data2%PedNrm%Read(File=TESTPEDNRMFILE, Ija=Ija(i))

          @AssertEqual(Data%PedNrm%nInd, Data2%PedNrm%nInd, "Pedigree NRM nInd were not assigned correctly with Ija="//Log2Char(Ija(i)))
          ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1=0, Data%RecPed%nInd)
          do Ind1 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data2%RecPed%OriginalId(Ind1))), "observed",  Data2%PedNrm%Nrm(0:Data%RecPed%nInd, Ind1)
            ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))),  "expected",   Data%PedNrm%Nrm(0:Data%RecPed%nInd, Ind1)
            ! write(STDOUT, "(a)") ""
            @AssertEqual(Data%RecPed%OriginalId(Ind1), Data2%RecPed%OriginalId(Ind1), "Pedigree NRM original Id were not written/read correctly with Ija="//Log2Char(Ija(i)))
            ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Observed", "Expected"
            do Ind2 = 0, Data%RecPed%nInd
              ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Nrm(Ind2, Ind1), Data%PedNrm%Nrm(Ind2, Ind1)
              @AssertEqual(Data%PedNrm%Nrm(Ind2, Ind1), Data2%PedNrm%Nrm(Ind2, Ind1), "Pedigree NRM values were not written/read correctly with Ija="//Log2Char(Ija(i)))
            end do
          end do
        end do

        call Data%Destroy
        call Data2%Destroy
        call DeletePedigreeFile
        open(newunit=Unit, file=TESTPEDNRMFILE, status="old")
        close(Unit, status="delete")
        open(newunit=Unit, file=trim(TESTPEDNRMFILE)//"_IdMap", status="old")
        close(Unit, status="delete")
      end subroutine

      !#########################################################################

      @test
      subroutine TestMatchIdNrm
        implicit none
        type(Nrm) :: x
        character(len=IDLENGTH), allocatable, dimension(:) :: Id1, Id2
        integer(int32) :: i
        integer(int32), allocatable, dimension(:) :: IdExp

        allocate(Id1(4))
        allocate(Id2(6))
        allocate(IdExp(4))
        Id1 = ["D", "C", "A", "X"]
        Id2 = ["A", "B", "C", "D", "E", "F"]
        call x%Init(nInd=4, OriginalId=Id1)
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 1")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 1b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [3, 2, 0, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 2")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 2b")
        end do

        deallocate(Id2)
        allocate(Id2(0:6))
        Id2 = ["0", "A", "B", "C", "D", "E", "F"]
        call x%MatchId(OriginalIdSuperset=Id2)
        IdExp = [5, 4, 2, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 3")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 3b")
        end do

        call x%MatchId(OriginalIdSuperset=Id2, Skip=1)
        IdExp = [4, 3, 1, 0]
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 4")
        end do
        call x%Init(nInd=4, OriginalId=Id1, OriginalIdSuperset=Id2, Skip=1)
        ! write(STDOUT, "(3a9)") " ", "Observed", "Expected"
        do i = 1, 4
          ! write(STDOUT, "(i8, a1, 2i9)") i, "", x%Id(i), IdExp(i)
          @AssertEqual(x%Id(i), IdExp(i), "MatchIdNrm broken 4b")
        end do
        deallocate(Id1)
        deallocate(Id2)
        deallocate(IdExp)
      end subroutine

      !#########################################################################

    !###########################################################################

    ! AlphaRelateData type tests

      !#########################################################################

      @test
      subroutine TestPedInbreedingRecursive
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind
        real(real64), allocatable, dimension(:) :: CalPedInbreeding, ExpPedInbreeding

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedInbreeding(0:Data%RecPed%nInd))
        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))

        CalPedInbreeding = PedInbreedingRecursive(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125, 0.125]

        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), CalPedInbreeding(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), CalPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly with recursive algorithm - tiny example for function")
        end do
        deallocate(CalPedInbreeding)
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)

        call CreatePedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedInbreeding(0:Data%RecPed%nInd))
        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))

        CalPedInbreeding = PedInbreedingRecursive(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0,   0.0,    0.0, 0.0, 0.0, 0.25,    0.25,    0.25,  0.375,    0.375,  0.375, &
                                                0.375,  0.4375, 0.5, 0.5, 0.5, 0.59375, 0.59375, 0.375, 0.484375, 0.4296875]
        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), CalPedInbreeding(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), CalPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly with recursive and Luo algorithm - example")
        end do
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("Porto","0","0")
        ! Ped[2, ] <- c("OldMoll","0","0")
        ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
        ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
        ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
        ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
        ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
        ! Ped[8, ] <- c("Peg","Dash1","Moll2")
        ! Ped[9, ] <- c("Rock","Pilot","Moll2")
        ! Ped[10, ] <- c("Regent","Pilot","Moll2")
        ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
        ! Ped[12, ] <- c("RockA","Peg","Rock")
        ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
        ! Ped[14, ] <- c("Rock2","Regent","Jet1")
        ! Ped[15, ] <- c("Fred1","RockA","Moll2")
        ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
        ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
        ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
        ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
        ! Ped[20, ] <- c("Dash2","Cora2","Sting")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestPedInbreedingMeuwissenLuo
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind
        real(real64), allocatable, dimension(:) :: CalPedInbreeding, ExpPedInbreeding

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedInbreeding(0:Data%RecPed%nInd))
        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))

        CalPedInbreeding = PedInbreedingMeuwissenLuo(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125, 0.125]

        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), CalPedInbreeding(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), CalPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly with Meuwissen and Luo algorithm - tiny example for function")
        end do
        deallocate(CalPedInbreeding)
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)

        call CreatePedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedInbreeding(0:Data%RecPed%nInd))
        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))

        CalPedInbreeding = PedInbreedingMeuwissenLuo(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0,   0.0,    0.0, 0.0, 0.0, 0.25,    0.25,    0.25,  0.375,    0.375,  0.375, &
                                                0.375,  0.4375, 0.5, 0.5, 0.5, 0.59375, 0.59375, 0.375, 0.484375, 0.4296875]
        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), CalPedInbreeding(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), CalPedInbreeding(Ind), "Pedigree inbreeding is not calculated correctly with Meuwissen and Luo algorithm - example")
        end do
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("Porto","0","0")
        ! Ped[2, ] <- c("OldMoll","0","0")
        ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
        ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
        ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
        ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
        ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
        ! Ped[8, ] <- c("Peg","Dash1","Moll2")
        ! Ped[9, ] <- c("Rock","Pilot","Moll2")
        ! Ped[10, ] <- c("Regent","Pilot","Moll2")
        ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
        ! Ped[12, ] <- c("RockA","Peg","Rock")
        ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
        ! Ped[14, ] <- c("Rock2","Regent","Jet1")
        ! Ped[15, ] <- c("Fred1","RockA","Moll2")
        ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
        ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
        ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
        ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
        ! Ped[20, ] <- c("Dash2","Cora2","Sting")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcPedInbreeding
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind
        real(real64), allocatable, dimension(:) :: ExpPedInbreeding

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedInbreeding

        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.125, 0.125]
        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), Data%PedInbreeding%Inb(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), Data%PedInbreeding%Inb(Ind), "Pedigree inbreeding is not calculated correctly - tiny example")
        end do
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)

        call CreatePedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedInbreeding

        allocate(ExpPedInbreeding(0:Data%RecPed%nInd))
        ExpPedInbreeding(0:Data%RecPed%nInd) = [-1.0,   0.0,    0.0, 0.0, 0.0, 0.25,    0.25,    0.25,  0.375,    0.375,  0.375, &
                                                0.375,  0.4375, 0.5, 0.5, 0.5, 0.59375, 0.59375, 0.375, 0.484375, 0.4296875]
        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%RecPed%OriginalId(Ind), ExpPedInbreeding(Ind), Data%PedInbreeding%Inb(Ind)
          @AssertEqual(ExpPedInbreeding(Ind), Data%PedInbreeding%Inb(Ind), "Pedigree inbreeding is not calculated correctly - example")
        end do
        deallocate(ExpPedInbreeding)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("Porto","0","0")
        ! Ped[2, ] <- c("OldMoll","0","0")
        ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
        ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
        ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
        ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
        ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
        ! Ped[8, ] <- c("Peg","Dash1","Moll2")
        ! Ped[9, ] <- c("Rock","Pilot","Moll2")
        ! Ped[10, ] <- c("Regent","Pilot","Moll2")
        ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
        ! Ped[12, ] <- c("RockA","Peg","Rock")
        ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
        ! Ped[14, ] <- c("Rock2","Regent","Jet1")
        ! Ped[15, ] <- c("Fred1","RockA","Moll2")
        ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
        ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
        ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
        ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
        ! Ped[20, ] <- c("Dash2","Cora2","Sting")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! inbreeding(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestPedNrmFunc
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2
        real(real64), allocatable, dimension(:, :) :: CalPedNrm, ExpPedNrm

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))

        CalPedNrm = PedNrm(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd)
        ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.00, 0.00, 0.000, 0.000, 0.0000, 0.0000, 0.0000, 0.0000] ! 0
        ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.00, 1.00, 0.000, 0.000, 0.5000, 0.5000, 0.5000, 0.2500] ! A
        ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.00, 0.00, 1.000, 0.000, 0.5000, 0.0000, 0.2500, 0.6250] ! B
        ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.00, 0.00, 0.000, 1.000, 0.0000, 0.5000, 0.2500, 0.1250] ! dum001
        ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.00, 0.50, 0.500, 0.000, 1.0000, 0.2500, 0.6250, 0.5625] ! C
        ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.00, 0.50, 0.000, 0.500, 0.2500, 1.0000, 0.6250, 0.3125] ! D
        ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.00, 0.50, 0.250, 0.250, 0.6250, 0.6250, 1.1250, 0.6875] ! E
        ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250] ! F

        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", CalPedNrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ", ExpPedNrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, CalPedNrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
            @AssertEqual(CalPedNrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM is not calculated correctly - tiny example for function")
          end do
        end do
        deallocate(CalPedNrm)
        deallocate(ExpPedNrm)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getA(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcPedNrm
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2
        real(real64), allocatable, dimension(:, :) :: ExpPedNrm

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedNrm(Spec=Spec)

        allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        !                                      0     A      B dum001       C       D       E       F
        ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.00, 0.00, 0.000, 0.000, 0.0000, 0.0000, 0.0000, 0.0000] ! 0
        ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.00, 1.00, 0.000, 0.000, 0.5000, 0.5000, 0.5000, 0.2500] ! A
        ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.00, 0.00, 1.000, 0.000, 0.5000, 0.0000, 0.2500, 0.6250] ! B
        ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.00, 0.00, 0.000, 1.000, 0.0000, 0.5000, 0.2500, 0.1250] ! dum001
        ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.00, 0.50, 0.500, 0.000, 1.0000, 0.2500, 0.6250, 0.5625] ! C
        ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.00, 0.50, 0.000, 0.500, 0.2500, 1.0000, 0.6250, 0.3125] ! D
        ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.00, 0.50, 0.250, 0.250, 0.6250, 0.6250, 1.1250, 0.6875] ! E
        ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250] ! F
        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrm%Nrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
            @AssertEqual(Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM is not calculated correctly - tiny example")
          end do
        end do
        deallocate(ExpPedNrm)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getA(Ped)

        call CreatePedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedNrm(Spec=Spec)

        allocate(ExpPedNrm(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        ExpPedNrm(0:Data%RecPed%nInd, 0) = [0.0, 0.0, 0.0, 0.0000000, 0.0000000, 0.000, 0.00000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.0000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.0000000, 0.0000000, 0.0000000]
        ExpPedNrm(0:Data%RecPed%nInd, 1) = [0.0, 1.0, 0.0, 0.5000000, 0.5000000, 0.500, 0.50000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.5000000, 0.5000000]
        ExpPedNrm(0:Data%RecPed%nInd, 2) = [0.0, 0.0, 1.0, 0.5000000, 0.5000000, 0.500, 0.50000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.500000, 0.500000, 0.500000, 0.500000, 0.500000, 0.5000000, 0.5000000, 0.5000000]
        ExpPedNrm(0:Data%RecPed%nInd, 3) = [0.0, 0.5, 0.5, 1.0000000, 0.5000000, 0.750, 0.75000, 0.750000, 0.875000, 0.750000, 0.750000, 0.750000, 0.8125000, 0.750000, 0.750000, 0.781250, 0.750000, 0.750000, 0.7656250, 0.7656250, 0.7578125]
        ExpPedNrm(0:Data%RecPed%nInd, 4) = [0.0, 0.5, 0.5, 0.5000000, 1.0000000, 0.750, 0.75000, 0.750000, 0.625000, 0.750000, 0.750000, 0.750000, 0.6875000, 0.750000, 0.750000, 0.718750, 0.750000, 0.750000, 0.7343750, 0.7343750, 0.7421875]
        ExpPedNrm(0:Data%RecPed%nInd, 5) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 1.250, 0.75000, 0.750000, 0.750000, 0.750000, 0.750000, 0.750000, 0.7500000, 0.750000, 0.750000, 0.750000, 0.750000, 0.750000, 1.0000000, 0.7500000, 0.8750000]
        ExpPedNrm(0:Data%RecPed%nInd, 6) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.25000, 0.750000, 1.000000, 1.000000, 1.000000, 1.000000, 1.0000000, 1.000000, 1.000000, 1.125000, 1.000000, 1.000000, 0.9375000, 1.0625000, 0.9687500]
        ExpPedNrm(0:Data%RecPed%nInd, 7) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 0.75000, 1.250000, 0.750000, 1.000000, 1.000000, 1.000000, 0.8750000, 1.000000, 1.000000, 0.812500, 1.000000, 1.000000, 0.7812500, 0.9062500, 0.8906250]
        ExpPedNrm(0:Data%RecPed%nInd, 8) = [0.0, 0.5, 0.5, 0.8750000, 0.6250000, 0.750, 1.00000, 0.750000, 1.375000, 0.875000, 0.875000, 0.875000, 1.1250000, 0.875000, 0.875000, 1.062500, 0.875000, 0.875000, 0.9062500, 0.9687500, 0.8906250]
        ExpPedNrm(0:Data%RecPed%nInd, 9) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.375000, 1.000000, 1.000000, 1.1250000, 1.000000, 1.000000, 1.062500, 1.000000, 1.000000, 0.9062500, 1.0312500, 0.9531250]
        ExpPedNrm(0:Data%RecPed%nInd,10) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.375000, 1.000000, 0.9375000, 1.187500, 1.187500, 0.968750, 1.187500, 1.187500, 0.8593750, 1.0781250, 1.0234375]
        ExpPedNrm(0:Data%RecPed%nInd,11) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.000000, 1.375000, 0.9375000, 1.187500, 1.187500, 0.968750, 1.187500, 1.187500, 0.8593750, 1.0781250, 1.0234375]
        ExpPedNrm(0:Data%RecPed%nInd,12) = [0.0, 0.5, 0.5, 0.8125000, 0.6875000, 0.750, 1.00000, 0.875000, 1.125000, 1.125000, 0.937500, 0.937500, 1.4375000, 0.937500, 0.937500, 1.218750, 0.937500, 0.937500, 0.9843750, 1.0781250, 0.9609375]
        ExpPedNrm(0:Data%RecPed%nInd,13) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.500000, 1.187500, 0.968750, 1.343750, 1.343750, 0.8593750, 1.1562500, 1.1015625]
        ExpPedNrm(0:Data%RecPed%nInd,14) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.187500, 1.500000, 0.968750, 1.343750, 1.343750, 0.8593750, 1.1562500, 1.1015625]
        ExpPedNrm(0:Data%RecPed%nInd,15) = [0.0, 0.5, 0.5, 0.7812500, 0.7187500, 0.750, 1.12500, 0.812500, 1.062500, 1.062500, 0.968750, 0.968750, 1.2187500, 0.968750, 0.968750, 1.500000, 0.968750, 0.968750, 1.1250000, 1.2343750, 1.0468750]
        ExpPedNrm(0:Data%RecPed%nInd,16) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.343750, 1.343750, 0.968750, 1.593750, 1.343750, 0.8593750, 1.1562500, 1.2265625]
        ExpPedNrm(0:Data%RecPed%nInd,17) = [0.0, 0.5, 0.5, 0.7500000, 0.7500000, 0.750, 1.00000, 1.000000, 0.875000, 1.000000, 1.187500, 1.187500, 0.9375000, 1.343750, 1.343750, 0.968750, 1.343750, 1.593750, 0.8593750, 1.2812500, 1.1015625]
        ExpPedNrm(0:Data%RecPed%nInd,18) = [0.0, 0.5, 0.5, 0.7656250, 0.7343750, 1.000, 0.93750, 0.781250, 0.906250, 0.906250, 0.859375, 0.859375, 0.9843750, 0.859375, 0.859375, 1.125000, 0.859375, 0.859375, 1.3750000, 0.9921875, 1.1171875]
        ExpPedNrm(0:Data%RecPed%nInd,19) = [0.0, 0.5, 0.5, 0.7656250, 0.7343750, 0.750, 1.06250, 0.906250, 0.968750, 1.031250, 1.078125, 1.078125, 1.0781250, 1.156250, 1.156250, 1.234375, 1.156250, 1.281250, 0.9921875, 1.4843750, 1.0742188]
        ExpPedNrm(0:Data%RecPed%nInd,20) = [0.0, 0.5, 0.5, 0.7578125, 0.7421875, 0.875, 0.96875, 0.890625, 0.890625, 0.953125, 1.023438, 1.023438, 0.9609375, 1.101562, 1.101562, 1.046875, 1.226562, 1.101562, 1.1171875, 1.0742188, 1.4296875]
        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrm%Nrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
            @AssertEqual(Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), 0.000001d0, "Pedigree NRM is not calculated correctly - tiny example")
          end do
        end do
        deallocate(ExpPedNrm)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("Porto","0","0")
        ! Ped[2, ] <- c("OldMoll","0","0")
        ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
        ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
        ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
        ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
        ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
        ! Ped[8, ] <- c("Peg","Dash1","Moll2")
        ! Ped[9, ] <- c("Rock","Pilot","Moll2")
        ! Ped[10, ] <- c("Regent","Pilot","Moll2")
        ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
        ! Ped[12, ] <- c("RockA","Peg","Rock")
        ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
        ! Ped[14, ] <- c("Rock2","Regent","Jet1")
        ! Ped[15, ] <- c("Fred1","RockA","Moll2")
        ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
        ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
        ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
        ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
        ! Ped[20, ] <- c("Dash2","Cora2","Sting")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getA(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestPedNrmTimesVectorFunc
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind
        real(real64), allocatable, dimension(:) :: CalPedNrmColumn, ExpPedNrmColumn, x

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(x(0:Data%RecPed%nInd))
        allocate(CalPedNrmColumn(0:Data%RecPed%nInd))
        allocate(ExpPedNrmColumn(0:Data%RecPed%nInd))

        call Data%CalcPedInbreeding()
        ! This application of PedNrmTimesVector() is to get the 7th column of Pedigree NRM
        x = [0, 0, 0, 0, 0, 0, 0, 1]
        CalPedNrmColumn = PedNrmTimesVector(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd,&
                                            Inbreeding=Data%PedInbreeding%Inb,&
                                            Vector=x)
        ExpPedNrmColumn(0:Data%RecPed%nInd) = [0.00, 0.25, 0.625, 0.125, 0.5625, 0.3125, 0.6875, 1.1250]

        ! write(STDOUT, "(a8, 2a16)") " ", "Calculated", "Expected"
        do Ind = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, 2f16.8)") Ind, CalPedNrmColumn(Ind), ExpPedNrmColumn(Ind)
          @AssertEqual(CalPedNrmColumn(Ind), ExpPedNrmColumn(Ind), "Pedigree NRM times a vector is not calculated correctly - tiny example for function")
        end do
        deallocate(CalPedNrmColumn)
        deallocate(ExpPedNrmColumn)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getA(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcPedNrmWithSubset
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2
        real(real64), allocatable, dimension(:, :) :: ExpPedNrm

        call CreateTinyPedigreeFile
        call CreateTinyPedNrmSubsetFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%CalcPedNrm(Spec=Spec)
        Spec%PedNrmSubsetGiven = .true.
        Spec%PedNrmSubsetFile = TESTPEDNRMSUBSETFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedNrm(Spec=Spec)
        ! call Data%PedNrm%Write(File="TestNrm2.txt", OutputFormat=Spec%OutputFormat)
        ! For individuals 0, B was 2nd now 1st, D was 5th now 2nd, F was 7th now 3rd
        allocate(ExpPedNrm(0:Data%PedNrm%nInd, 0:Data%PedNrm%nInd))
        ExpPedNrm(0:Data%PedNrm%nInd, 0) = [0.00, 0.000, 0.0000, 0.0000] ! 0
        ExpPedNrm(0:Data%PedNrm%nInd, 1) = [0.00, 1.000, 0.0000, 0.6250] ! B
        ExpPedNrm(0:Data%PedNrm%nInd, 2) = [0.00, 0.000, 1.0000, 0.3125] ! D
        ExpPedNrm(0:Data%PedNrm%nInd, 3) = [0.00, 0.625, 0.3125, 1.1250] ! F

        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%PedNrm%nInd)
        do Ind1 = 0, Data%PedNrm%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%PedNrm%OriginalId(Ind1))), "calculated", Data%PedNrm%Nrm(0:Data%PedNrm%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%PedNrm%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%PedNrm%OriginalId(Ind1))), "expected  ",         ExpPedNrm(0:Data%PedNrm%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%PedNrm%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1)
            @AssertEqual(Data%PedNrm%Nrm(Ind2, Ind1), ExpPedNrm(Ind2, Ind1), "Pedigree NRM with subset is not calculated correctly")
          end do
        end do
        deallocate(ExpPedNrm)
        call Data%Destroy
        call DeletePedigreeFile
        call DeletePedNrmSubsetFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getA(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestPedNrmInvFunc
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2
        real(real64), allocatable, dimension(:, :) :: CalPedNrmInv, ExpPedNrmInv

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        allocate(CalPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))

        call Data%CalcPedInbreeding()
        CalPedNrmInv = PedNrmInv(RecPed=Data%RecPed%Id, n=Data%RecPed%nInd, Inbreeding=Data%PedInbreeding%Inb)
        ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  0.5000000,  0.5, -1.0, -1.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  0.5,  2.0333333,  0.0, -1.0,  0.0,  0.5333333, -1.066667]
        ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0,  0.5,  0.0000000,  1.5,  0.0, -1.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0000000,  0.0,  2.5,  0.5, -1.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0, -1.0,  0.0000000, -1.0,  0.5,  2.5, -1.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.5333333,  0.0, -1.0, -1.0,  2.5333333, -1.066667]
        ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0, -1.0666667,  0.0,  0.0,  0.0, -1.0666667,  2.133333]

        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", CalPedNrmInv(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ", ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, CalPedNrmInv(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
            @AssertEqual(CalPedNrmInv(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example for function")
          end do
        end do
        deallocate(CalPedNrmInv)
        deallocate(ExpPedNrmInv)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getAInv(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcPedNrmInv
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2
        real(real64), allocatable, dimension(:, :) :: ExpPedNrmInv

        call CreateTinyPedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedNrmInv

        allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  0.5000000,  0.5, -1.0, -1.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  0.5,  2.0333333,  0.0, -1.0,  0.0,  0.5333333, -1.066667]
        ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0,  0.5,  0.0000000,  1.5,  0.0, -1.0,  0.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0000000,  0.0,  2.5,  0.5, -1.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0, -1.0,  0.0000000, -1.0,  0.5,  2.5, -1.0000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.5333333,  0.0, -1.0, -1.0,  2.5333333, -1.066667]
        ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0, -1.0666667,  0.0,  0.0,  0.0, -1.0666667,  2.133333]
        ! write(STDOUT, "(a9, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrmInv%Nrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrmInv%Nrm(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
            @AssertEqual(Data%PedNrmInv%Nrm(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example")
          end do
        end do
        deallocate(ExpPedNrmInv)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(0, 7), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("A","0","0")
        ! Ped[2, ] <- c("B","0","0")
        ! Ped[3, ] <- c("dum001","0","0")
        ! Ped[4, ] <- c("C","A","B")
        ! Ped[5, ] <- c("D","A","dum001")
        ! Ped[6, ] <- c("E","D","C")
        ! Ped[7, ] <- c("F","E","B")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getAInv(Ped)

        call CreatePedigreeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        call Data%Read(Spec=Spec)

        call Data%CalcPedNrmInv

        allocate(ExpPedNrmInv(0:Data%RecPed%nInd, 0:Data%RecPed%nInd))
        ExpPedNrmInv(0:Data%RecPed%nInd, 0) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 1) = [0.0,  2.0,  1.0, -1.0000000, -1.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 2) = [0.0,  1.0,  2.0, -1.0000000, -1.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 3) = [0.0, -1.0, -1.0,  4.0714286,  1.5, -1.0, -0.4285714, -1.000000, -1.142857,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 4) = [0.0, -1.0, -1.0,  1.5000000,  3.5, -1.0, -1.0000000, -1.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 5) = [0.0,  0.0,  0.0, -1.0000000, -1.0,  2.8,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.800000,  0.000000,  0.000000, -1.600000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 6) = [0.0,  0.0,  0.0, -0.4285714, -1.0,  0.0,  5.3333333,  2.000000, -1.142857, -1.333333, -1.333333, -1.333333,  0.7619048,  0.0,  0.0, -1.523810,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 7) = [0.0,  0.0,  0.0, -1.0000000, -1.0,  0.0,  2.0000000,  4.000000,  0.000000, -1.333333, -1.333333, -1.333333,  0.0000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 8) = [0.0,  0.0,  0.0, -1.1428571,  0.0,  0.0, -1.1428571,  0.000000,  3.085714,  0.800000,  0.000000,  0.000000, -1.6000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd, 9) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.800000,  3.466667,  0.000000,  0.000000, -1.6000000,  0.0,  0.0,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,10) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.000000,  0.000000,  4.266667,  1.600000,  0.0000000, -1.6, -1.6,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,11) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0, -1.3333333, -1.333333,  0.000000,  0.000000,  1.600000,  4.266667,  0.0000000, -1.6, -1.6,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,12) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.7619048,  0.000000, -1.600000, -1.600000,  0.000000,  0.000000,  3.9619048,  0.0,  0.0, -1.523810,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,13) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000, -1.600000, -1.600000,  0.0000000,  5.2,  2.0,  0.000000, -2.000000, -2.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,14) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000, -1.600000, -1.600000,  0.0000000,  2.0,  5.2,  0.000000, -2.000000, -2.000000,  0.000000,  0.000000,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,15) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.8, -1.5238095,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000, -1.5238095,  0.0,  0.0,  4.951067,  0.000000,  1.103448, -1.600000, -2.206897,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,16) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000, -2.0, -2.0,  0.000000,  4.969697,  0.000000,  0.969697,  0.000000, -1.939394]
        ExpPedNrmInv(0:Data%RecPed%nInd,17) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000, -2.0, -2.0,  1.103448,  0.000000,  5.103448,  0.000000, -2.206897,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,18) = [0.0,  0.0,  0.0,  0.0000000,  0.0, -1.6,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0, -1.600000,  0.969697,  0.000000,  4.169697,  0.000000, -1.939394]
        ExpPedNrmInv(0:Data%RecPed%nInd,19) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0, -2.206897,  0.000000, -2.206897,  0.000000,  4.413793,  0.000000]
        ExpPedNrmInv(0:Data%RecPed%nInd,20) = [0.0,  0.0,  0.0,  0.0000000,  0.0,  0.0,  0.0000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.000000,  0.0000000,  0.0,  0.0,  0.000000, -1.939394,  0.000000, -1.939394,  0.000000,  3.878788]
        ! write(STDOUT, "(a9, 2a11,"//Int2Char(Data%RecPed%nInd+1)//"i16)") "", "", "", (Ind1, Ind1 = 0, Data%RecPed%nInd)
        do Ind1 = 0, Data%RecPed%nInd
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "calculated", Data%PedNrmInv%Nrm(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%RecPed%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%RecPed%OriginalId(Ind1))), "expected  ",         ExpPedNrmInv(0:Data%RecPed%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Calculated", "Expected"
          do Ind2 = 0, Data%RecPed%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind1, Ind2, Data%PedNrmInv%Nrm(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1)
            @AssertEqual(Data%PedNrmInv%Nrm(Ind2, Ind1), ExpPedNrmInv(Ind2, Ind1), 0.000001d0, "Pedigree NRM inverse is not calculated correctly - tiny example")
          end do
        end do
        deallocate(ExpPedNrmInv)
        call Data%Destroy
        call DeletePedigreeFile
        ! R code to test using the pedigreemm package
        ! library(pedigreemm)
        ! Ped <- data.frame(Id=rep(9, 20), Fid=NA, Mid=NA)
        ! Ped[1, ] <- c("Porto","0","0")
        ! Ped[2, ] <- c("OldMoll","0","0")
        ! Ped[3, ] <- c("Dash1","Porto","OldMoll")
        ! Ped[4, ] <- c("Belle1","Porto","OldMoll")
        ! Ped[5, ] <- c("Cora1","Dash1","Belle1")
        ! Ped[6, ] <- c("Moll2","Dash1","Belle1")
        ! Ped[7, ] <- c("Pilot","Dash1","Belle1")
        ! Ped[8, ] <- c("Peg","Dash1","Moll2")
        ! Ped[9, ] <- c("Rock","Pilot","Moll2")
        ! Ped[10, ] <- c("Regent","Pilot","Moll2")
        ! Ped[11, ] <- c("Jet1","Pilot","Moll2")
        ! Ped[12, ] <- c("RockA","Peg","Rock")
        ! Ped[13, ] <- c("CoraBlairs","Regent","Jet1")
        ! Ped[14, ] <- c("Rock2","Regent","Jet1")
        ! Ped[15, ] <- c("Fred1","RockA","Moll2")
        ! Ped[16, ] <- c("Sting","CoraBlairs","Rock2")
        ! Ped[17, ] <- c("Belle2","CoraBlairs","Rock2")
        ! Ped[18, ] <- c("Cora2","Cora1","Fred1")
        ! Ped[19, ] <- c("Moll3","Fred1","Belle2")
        ! Ped[20, ] <- c("Dash2","Cora2","Sting")
        ! Ped <- pedigree(sire = Ped$Fid, dam=Ped$Mid, label =Ped$Id)
        ! getAInv(Ped)
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcAlleleFreq
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Loc
        real(real64), allocatable, dimension(:) :: AlleleFreqExp

        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 2
        call Data%Read(Spec=Spec)
        call Data%CalcAlleleFreq
        allocate(AlleleFreqExp(Spec%nLoc))
        AlleleFreqExp(1) = 1/2.0d0
        AlleleFreqExp(2) = 2/3.0d0

        ! write(STDOUT, "(a8, 2a16)") "Locus", "Expected", "Observed"
        do Loc = 1, Data%Gen%nLoc
          ! write(STDOUT, "(i8, 2f)") Loc, AlleleFreqExp(Loc), Data%AlleleFreq%Value(Loc)
          @AssertEqual(AlleleFreqExp(Loc), Data%AlleleFreq%Value(Loc), "Allele frequencies not calculated correctly")
        end do
        deallocate(AlleleFreqExp)

        call CreateTinyGenotypeFileWithMissing
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 4
        call Data%Read(Spec=Spec)
        call Data%CalcAlleleFreq
        allocate(AlleleFreqExp(Spec%nLoc))
        AlleleFreqExp(1) = 1/2.0d0
        AlleleFreqExp(2) = 2/3.0d0
        AlleleFreqExp(3) = 1.0d0
        AlleleFreqExp(4) = 0.0d0

        ! write(STDOUT, "(a8, 2a16)") "Locus", "Expected", "Observed"
        do Loc = 1, Data%Gen%nLoc
          ! write(STDOUT, "(i8, 2f)") Loc, AlleleFreqExp(Loc), Data%AlleleFreq%Value(Loc)
          @AssertEqual(AlleleFreqExp(Loc), Data%AlleleFreq%Value(Loc), "Allele frequencies not calculated correctly - missing")
        end do

        deallocate(AlleleFreqExp)
        call Data%Destroy
        call DeleteGenotypeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcGenNrm
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2!, Ind
        real(real64), allocatable, dimension(:, :) :: ExpGenNrm

        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        allocate(ExpGenNrm(0:3, 0:3))

        ! 1 locus

        Spec%nLoc = 1
        Spec%GenNrmType = "vanraden1"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.00, 0.00,  0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  2.00, 0.00, -2.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  0.00, 0.00,  0.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -2.00, 0.00,  2.00] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 1 is not calculated correctly - tiny one marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "vanraden2"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.00, 0.00,  0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  2.00, 0.00, -2.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  0.00, 0.00,  0.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -2.00, 0.00,  2.00] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 2 is not calculated correctly - tiny one marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "yang"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.00, 0.00,  0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  2.00, 0.00, -2.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  0.00, 0.00,  0.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -2.00, 0.00,  2.00] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Yang is not calculated correctly - tiny one marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "nejati-javaremi"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.00, 0.00,  0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  2.00, 1.00,  0.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  1.00, 1.00,  1.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00,  0.00, 1.00,  2.00] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Nejati-Javaremi is not calculated correctly - tiny one marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        call Data%Destroy

        ! 2 loci

        Spec%nLoc = 2
        Spec%GenNrmType = "vanraden1"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,   0.00, 0.00,    0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  20.00, -4.00, -16.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  -4.00,  8.00,  -4.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -16.00, -4.00,  20.00] ! E
        ExpGenNrm = ExpGenNrm / 17.0d0
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 1 is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "vanraden2"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,   0.000,  0.00,  0.000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,   1.125, -0.25, -0.875] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  -0.250,  0.50, -0.250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00,  -0.875, -0.25,  1.125] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 2 is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "yang"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,   0.000,  0.00,  0.000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,   1.000, -0.25, -0.875] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  -0.250,  0.75, -0.250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00,  -0.875, -0.25,  1.000] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Yang is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "nejati-javaremi"
        call Data%Read(Spec=Spec)
        call Data%CalcGenNrm(Spec=Spec)
        !                                  0    B    D    E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.0, 0.0, 0.0, 0.0] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.0, 1.5, 1.0, 0.5] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.0, 1.0, 1.5, 1.0] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.0, 0.5, 1.0, 1.5] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Nejati-Javaremi is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        deallocate(ExpGenNrm)
        call Data%Destroy
        call DeleteGenotypeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcGenNrmWithWeights
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2!, Ind
        real(real64), allocatable, dimension(:, :) :: ExpGenNrm

        call CreateTinyGenotypeFile
        call CreateLocusWeightFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%LocusWeightGiven = .true.
        Spec%LocusWeightFile = TESTLWFILE
        Spec%nLoc = 2
        allocate(ExpGenNrm(0:3, 0:3))

        Spec%GenNrmType = "vanraden1"

        call Data%Read(Spec=Spec)
        ! Make constant weights
        Data%LocusWeight%Value = [1.0, 1.0]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B       D       E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,   0.00,  0.00,   0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  20.00, -4.00, -16.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  -4.00,  8.00,  -4.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -16.00, -4.00,  20.00] ! E
        ExpGenNrm = ExpGenNrm / 17.0d0
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 1 with constant weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        call Data%Read(Spec=Spec)
        ! Make variable weights
        Data%LocusWeight%Value = [1.0, 0.5]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0       B      D       E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,   0.00,  0.00,   0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  19.00, -2.00, -17.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  -2.00,  4.00,  -2.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -17.00, -2.00,  19.00] ! E
        ExpGenNrm = ExpGenNrm / 17.0d0
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 1 with variable weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "vanraden2"

        call Data%Read(Spec=Spec)
        ! Make constant weights
        Data%LocusWeight%Value = [1.0, 1.0]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0       B      D       E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.000,  0.00,  0.000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  1.125, -0.25, -0.875] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00, -0.250,  0.50, -0.250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -0.875, -0.25,  1.125] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 2 with constant weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        call Data%Read(Spec=Spec)
        ! Make variable weights
        Data%LocusWeight%Value = [1.0, 0.5]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0        B        D        E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.0000,  0.0000,  0.0000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  1.0625, -0.1250, -0.9375] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00, -0.1250,  0.2500, -0.1250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -0.9375, -0.1250,  1.0625] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Vanraden 2 with variable weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "yang"

        call Data%Read(Spec=Spec)
        ! Make constant weights
        Data%LocusWeight%Value = [1.0, 1.0]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.000,  0.00,  0.000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  1.000, -0.25, -0.875] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00, -0.250,  0.75, -0.250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -0.875, -0.25,  1.000] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Yang with constant weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        call Data%Read(Spec=Spec)
        ! Make variable weights
        Data%LocusWeight%Value = [1.0, 0.5]
        call Data%CalcGenNrm(Spec=Spec)
        !                                   0        B        D        E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.0000,  0.0000,  0.0000] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  1.0000, -0.1250, -0.9375] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00, -0.1250,  0.3750, -0.1250] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -0.9375, -0.1250,  1.0000] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Yang with variable weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        Spec%GenNrmType = "nejati-javaremi"

        call Data%Read(Spec=Spec)
        ! Make constant weights
        Data%LocusWeight%Value = [1.0, 1.0]
        call Data%CalcGenNrm(Spec=Spec)
        !                                  0    B    D    E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.0, 0.0, 0.0, 0.0] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.0, 1.5, 1.0, 0.5] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.0, 1.0, 1.5, 1.0] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.0, 0.5, 1.0, 1.5] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Nejati-Javaremi with constant weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        call Data%Read(Spec=Spec)
        ! Make variable weights
        Data%LocusWeight%Value = [1.0, 0.5]
        call Data%CalcGenNrm(Spec=Spec)
        !                                  0     B     D     E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.0, 0.00, 0.00, 0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.0, 1.25, 0.75, 0.25] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.0, 0.75, 1.00, 0.75] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.0, 0.25, 0.75, 1.25] ! E
        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM Nejati-Javaremi with variable weights is not calculated correctly - tiny two marker example")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        deallocate(ExpGenNrm)
        call Data%Destroy
        call DeleteLocusWeightFile
        call DeleteGenotypeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcGenNrmWithFudgeDiagAndBlend
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2!, Ind
        real(real64), allocatable, dimension(:, :) :: ExpGenNrm

        call CreateTinyPedigreeFile
        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%PedigreeGiven = .true.
        Spec%PedigreeFile = TESTPEDFILE
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 1
        Spec%GenNrmType = "vanraden1"
        Spec%FudgeGenNrmDiag = .true.
        Spec%FudgeGenNrmDiagValue = 0.01d0
        Spec%BlendGenNrmWithPedNrm = .true.
        Spec%BlendGenNrmWithPedNrmFactor = [0.8d0, 0.2d0]
        call Data%Read(Spec=Spec)

        call Data%CalcGenNrm(Spec=Spec)
        allocate(ExpGenNrm(0:3, 0:3))
        ! GNRM                              0      B     D      E
        ExpGenNrm(0:Data%Gen%nInd, 0) = [0.00,  0.00, 0.00,  0.00] ! 0
        ExpGenNrm(0:Data%Gen%nInd, 1) = [0.00,  2.00, 0.00, -2.00] ! B
        ExpGenNrm(0:Data%Gen%nInd, 2) = [0.00,  0.00, 0.00,  0.00] ! D
        ExpGenNrm(0:Data%Gen%nInd, 3) = [0.00, -2.00, 0.00,  2.00] ! E
        ! Fudge diag
        ExpGenNrm(1, 1) = ExpGenNrm(1, 1) + Spec%FudgeGenNrmDiagValue
        ExpGenNrm(2, 2) = ExpGenNrm(2, 2) + Spec%FudgeGenNrmDiagValue
        ExpGenNrm(3, 3) = ExpGenNrm(3, 3) + Spec%FudgeGenNrmDiagValue
        ! Blend with PNRM                                                                                                                             B      D      E
        ExpGenNrm(1:Data%Gen%nInd, 1) = Spec%BlendGenNrmWithPedNrmFactor(1) * ExpGenNrm(1:Data%Gen%nInd, 1) + Spec%BlendGenNrmWithPedNrmFactor(2) * [1.00d0, 0.000d0, 0.250d0] ! B
        ExpGenNrm(1:Data%Gen%nInd, 2) = Spec%BlendGenNrmWithPedNrmFactor(1) * ExpGenNrm(1:Data%Gen%nInd, 2) + Spec%BlendGenNrmWithPedNrmFactor(2) * [0.00d0, 1.000d0, 0.625d0] ! D
        ExpGenNrm(1:Data%Gen%nInd, 3) = Spec%BlendGenNrmWithPedNrmFactor(1) * ExpGenNrm(1:Data%Gen%nInd, 3) + Spec%BlendGenNrmWithPedNrmFactor(2) * [0.25d0, 0.625d0, 1.125d0] ! E

        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrm%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrm(Ind2, Ind1), Data%GenNrm%Nrm(Ind2, Ind1), 0.000001d0, "Fudged and blended Genotype NRM not calculated correctly")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        deallocate(ExpGenNrm)
        call Data%Destroy
        call DeleteGenotypeFile
        call DeletePedigreeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcGenNrmInv
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind1, Ind2!, Ind
        real(real64), allocatable, dimension(:, :) :: ExpGenNrmInv
        logical :: InversionSucceded

        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 1
        Spec%GenNrmType = "vanraden1"
        Spec%FudgeGenNrmDiag = .true.
        Spec%FudgeGenNrmDiagValue = 0.01d0
        call Data%Read(Spec=Spec)

        call Data%CalcGenNrmInv(Spec=Spec, Info=InversionSucceded)
        allocate(ExpGenNrmInv(0:3, 0:3))
        !                                     0        B      D         E
        ExpGenNrmInv(0:Data%Gen%nInd, 0) = [0.0,     0.0,   0.0,      0.0] ! 0
        ExpGenNrmInv(0:Data%Gen%nInd, 1) = [0.0, 20100.0,   0.0,  20000.0] ! B
        ExpGenNrmInv(0:Data%Gen%nInd, 2) = [0.0,     0.0, 401.0,      0.0] ! D
        ExpGenNrmInv(0:Data%Gen%nInd, 3) = [0.0, 20000.0,   0.00, 20100.0] ! E
        ExpGenNrmInv = ExpGenNrmInv / 401.0

        ! call Data%Write
        do Ind1 = 0, Data%Gen%nInd
          ! write(STDOUT, "(a9,     2a11, "//Int2Char(Data%Gen%nInd+1)//"i16)") "", "", "", (Ind, Ind = 0, Data%Gen%nInd)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "calculated", Data%GenNrmInv%Nrm(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(i8, a1, 2a11, "//Int2Char(Data%Gen%nInd+1)//"f16.8)") Ind1, "", adjustr(trim(Data%Gen%OriginalId(Ind1))), "expected  ",       ExpGenNrmInv(0:Data%Gen%nInd, Ind1)
          ! write(STDOUT, "(a)") ""
          ! write(STDOUT, "(2a8, 2a16)") " ", " ", "Expected", "Calculated"
          do Ind2 = 0, Data%Gen%nInd
            ! write(STDOUT, "(2i8, 2f16.8)") Ind2, Ind1, ExpGenNrmInv(Ind2, Ind1), Data%GenNrmInv%Nrm(Ind2, Ind1)
            @AssertEqual(ExpGenNrmInv(Ind2, Ind1), Data%GenNrmInv%Nrm(Ind2, Ind1), 0.000001d0, "Genotype NRM inverse not calculated correctly")
          end do
          ! write(STDOUT, "(a)") ""
        end do

        deallocate(ExpGenNrmInv)
        call Data%Destroy
        call DeleteGenotypeFile
        call DeletePedigreeFile
      end subroutine

      !#########################################################################

      @test
      subroutine TestCalcGenInbreeding
        implicit none
        type(AlphaRelateSpec) :: Spec
        type(AlphaRelateData) :: Data
        integer(int32) :: Ind
        real(real64), allocatable, dimension(:) :: ExpGenInbreeding

        call CreateTinyGenotypeFile
        call Spec%Init
        Spec%GenotypeGiven = .true.
        Spec%GenotypeFile = TESTGENFILE
        Spec%nLoc = 1
        Spec%GenNrmType = "vanraden1"
        call Data%Read(Spec=Spec)
        call Data%CalcGenInbreeding(Spec=Spec)
        allocate(ExpGenInbreeding(0:3))
        !                                        0     B      D     E
        ExpGenInbreeding(0:Data%Gen%nInd) = [-1.00, 1.00, -1.00, 1.00]
        ! call Data%Write
        ! write(STDOUT, "(2a9, 2a16)") " ", " ", "Expected", "Calculated"
        do Ind = 0, Data%GenInbreeding%nInd
          ! write(STDOUT, "(i8, a1, a9, 2f16.8)") Ind, Data%GenInbreeding%OriginalId(Ind), ExpGenInbreeding(Ind), Data%GenInbreeding%Inb(Ind)
          @AssertEqual(ExpGenInbreeding(Ind), Data%GenInbreeding%Inb(Ind), 0.000001d0, "Genotype inbreeding is not calculated correctly - tiny example")
        end do
        deallocate(ExpGenInbreeding)
        call Data%Destroy
        call DeleteGenotypeFile
      end subroutine

      !#########################################################################

    !###########################################################################

end module

!###############################################################################
